//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class EvenDemandDataImportConfiguration: BirchModel, Decodable, AutoEquatable {

    public enum EvenProductType: String, Codable, Equatable, CaseIterable {
        case creditCard = "credit_card"
        case insurance = "insurance"
        case lifeInsurance = "life_insurance"
        case loan = "loan"
        case mortgage = "mortgage"
        case savings = "savings"
        case other = "other"
        case unknown = "unknown"
        case undecodable

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(String.self)
            self = EvenProductType(rawValue: rawValue) ?? .undecodable
        }
    }

    public enum EvenFileType: String, Codable, Equatable, CaseIterable {
        case csv = "csv"
        case json = "json"
        case xlsx = "xlsx"
        case undecodable

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(String.self)
            self = EvenFileType(rawValue: rawValue) ?? .undecodable
        }
    }

    /** A unique, internal identifier for this resource.
 */
    public var id: Int

    public var subAccountId: Int

    public var productType: EvenProductType

    public var effectiveAt: DateTime

    /** A comma-separated list of field names that are standard for each file that uses this configuration
 */
    public var fieldNames: [String]

    public var fileType: EvenFileType

    public var leadUuidProcessorInformation: EvenAppliedTimestampProcessor

    public var details: Even0

    /** When the resource was created.
 */
    public var createdAt: DateTime

    /** The UUID of the access token that was used to create this resource.
 */
    public var createdBy: ID

    public var dataRow: String?

    /** When the resource was deleted.
 */
    public var deletedAt: DateTime?

    /** The UUID of the access token that was used to delete this resource.
 */
    public var deletedBy: ID?

    public var headerRow: String?

    public var offerIdProcessorInformation: EvenAppliedTimestampProcessor?

    public var productSubTypeProcessorInformation: EvenAppliedTimestampProcessor?

    public var sheetNumber: String?

    public init(id: Int, subAccountId: Int, productType: EvenProductType, effectiveAt: DateTime, fieldNames: [String], fileType: EvenFileType, leadUuidProcessorInformation: EvenAppliedTimestampProcessor, details: Even0, createdAt: DateTime, createdBy: ID, dataRow: String? = nil, deletedAt: DateTime? = nil, deletedBy: ID? = nil, headerRow: String? = nil, offerIdProcessorInformation: EvenAppliedTimestampProcessor? = nil, productSubTypeProcessorInformation: EvenAppliedTimestampProcessor? = nil, sheetNumber: String? = nil) {
        self.id = id
        self.subAccountId = subAccountId
        self.productType = productType
        self.effectiveAt = effectiveAt
        self.fieldNames = fieldNames
        self.fileType = fileType
        self.leadUuidProcessorInformation = leadUuidProcessorInformation
        self.details = details
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.dataRow = dataRow
        self.deletedAt = deletedAt
        self.deletedBy = deletedBy
        self.headerRow = headerRow
        self.offerIdProcessorInformation = offerIdProcessorInformation
        self.productSubTypeProcessorInformation = productSubTypeProcessorInformation
        self.sheetNumber = sheetNumber
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        id = try container.decode("id")
        subAccountId = try container.decode("subAccountId")
        productType = try container.decode("productType")
        effectiveAt = try container.decode("effectiveAt")
        fieldNames = try container.decodeArray("fieldNames")
        fileType = try container.decode("fileType")
        leadUuidProcessorInformation = try container.decode("leadUuidProcessorInformation")
        details = try container.decode("details")
        createdAt = try container.decode("createdAt")
        createdBy = try container.decode("createdBy")
        dataRow = try container.decodeIfPresent("dataRow")
        deletedAt = try container.decodeIfPresent("deletedAt")
        deletedBy = try container.decodeIfPresent("deletedBy")
        headerRow = try container.decodeIfPresent("headerRow")
        offerIdProcessorInformation = try container.decodeIfPresent("offerIdProcessorInformation")
        productSubTypeProcessorInformation = try container.decodeIfPresent("productSubTypeProcessorInformation")
        sheetNumber = try container.decodeIfPresent("sheetNumber")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encode(id, forKey: "id")
        try container.encode(subAccountId, forKey: "subAccountId")
        try container.encode(productType, forKey: "productType")
        try container.encode(effectiveAt, forKey: "effectiveAt")
        try container.encode(fieldNames, forKey: "fieldNames")
        try container.encode(fileType, forKey: "fileType")
        try container.encode(leadUuidProcessorInformation, forKey: "leadUuidProcessorInformation")
        try container.encode(details, forKey: "details")
        try container.encode(createdAt, forKey: "createdAt")
        try container.encode(createdBy, forKey: "createdBy")
        try container.encodeIfPresent(dataRow, forKey: "dataRow")
        try container.encodeIfPresent(deletedAt, forKey: "deletedAt")
        try container.encodeIfPresent(deletedBy, forKey: "deletedBy")
        try container.encodeIfPresent(headerRow, forKey: "headerRow")
        try container.encodeIfPresent(offerIdProcessorInformation, forKey: "offerIdProcessorInformation")
        try container.encodeIfPresent(productSubTypeProcessorInformation, forKey: "productSubTypeProcessorInformation")
        try container.encodeIfPresent(sheetNumber, forKey: "sheetNumber")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? EvenDemandDataImportConfiguration else { return false }
      guard self.id == object.id else { return false }
      guard self.subAccountId == object.subAccountId else { return false }
      guard self.productType == object.productType else { return false }
      guard self.effectiveAt == object.effectiveAt else { return false }
      guard self.fieldNames == object.fieldNames else { return false }
      guard self.fileType == object.fileType else { return false }
      guard self.leadUuidProcessorInformation == object.leadUuidProcessorInformation else { return false }
      guard self.details == object.details else { return false }
      guard self.createdAt == object.createdAt else { return false }
      guard self.createdBy == object.createdBy else { return false }
      guard self.dataRow == object.dataRow else { return false }
      guard self.deletedAt == object.deletedAt else { return false }
      guard self.deletedBy == object.deletedBy else { return false }
      guard self.headerRow == object.headerRow else { return false }
      guard self.offerIdProcessorInformation == object.offerIdProcessorInformation else { return false }
      guard self.productSubTypeProcessorInformation == object.productSubTypeProcessorInformation else { return false }
      guard self.sheetNumber == object.sheetNumber else { return false }
      return true
    }

    public static func == (lhs: EvenDemandDataImportConfiguration, rhs: EvenDemandDataImportConfiguration) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
