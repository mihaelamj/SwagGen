//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class EvenAccount: BirchModel, Decodable, AutoEquatable {

    /** A unique, internal identifier for this resource.
 */
    public var id: Int

    /** A unique identifier for this resource.
 */
    public var uuid: ID

    public var name: String

    public var billingSetup: Bool

    /** When the resource was created.
 */
    public var createdAt: DateTime

    /** The UUID of the access token that was used to create this resource.
 */
    public var createdBy: ID

    public var accountOwners: AccountOwners?

    public var address1: String?

    public var address2: String?

    public var address3: String?

    public var billingName: String?

    public var city: String?

    public var country: String?

    /** When the resource was deactivated.
 */
    public var deactivatedAt: DateTime?

    /** The UUID of the access token that was used to deactivated this resource.
 */
    public var deactivatedBy: ID?

    /** When the resource was deleted.
 */
    public var deletedAt: DateTime?

    /** The UUID of the access token that was used to delete this resource.
 */
    public var deletedBy: ID?

    public var email: String?

    public var phoneNumber: String?

    public var receivableBillingName: String?

    public var state: String?

    public var zipcode: String?

    public class AccountOwners: BirchModel, Decodable, AutoEquatable {

        /** A unique, internal identifier for this resource.
     */
        public var id: Int

        /** An identifier for the associated account
     */
        public var accountId: Int

        /** When the resource was created.
     */
        public var createdAt: DateTime

        /** The UUID of the access token that was used to create this resource.
     */
        public var createdBy: ID

        /** When the resource was deleted.
     */
        public var deletedAt: DateTime?

        /** The UUID of the access token that was used to delete this resource.
     */
        public var deletedBy: ID?

        /** A unique identifier for the demand partner manager.
     */
        public var demandPartnerManager: ID?

        /** A unique identifier for the demand yield manager.
     */
        public var demandYieldManager: ID?

        /** A unique identifier for the supply partner manager.
     */
        public var supplyPartnerManager: ID?

        /** A unique identifier for the supply yield manager.
     */
        public var supplyYieldManager: ID?

        public init(id: Int, accountId: Int, createdAt: DateTime, createdBy: ID, deletedAt: DateTime? = nil, deletedBy: ID? = nil, demandPartnerManager: ID? = nil, demandYieldManager: ID? = nil, supplyPartnerManager: ID? = nil, supplyYieldManager: ID? = nil) {
            self.id = id
            self.accountId = accountId
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.deletedAt = deletedAt
            self.deletedBy = deletedBy
            self.demandPartnerManager = demandPartnerManager
            self.demandYieldManager = demandYieldManager
            self.supplyPartnerManager = supplyPartnerManager
            self.supplyYieldManager = supplyYieldManager
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            id = try container.decode("id")
            accountId = try container.decode("accountId")
            createdAt = try container.decode("createdAt")
            createdBy = try container.decode("createdBy")
            deletedAt = try container.decodeIfPresent("deletedAt")
            deletedBy = try container.decodeIfPresent("deletedBy")
            demandPartnerManager = try container.decodeIfPresent("demandPartnerManager")
            demandYieldManager = try container.decodeIfPresent("demandYieldManager")
            supplyPartnerManager = try container.decodeIfPresent("supplyPartnerManager")
            supplyYieldManager = try container.decodeIfPresent("supplyYieldManager")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(id, forKey: "id")
            try container.encode(accountId, forKey: "accountId")
            try container.encode(createdAt, forKey: "createdAt")
            try container.encode(createdBy, forKey: "createdBy")
            try container.encodeIfPresent(deletedAt, forKey: "deletedAt")
            try container.encodeIfPresent(deletedBy, forKey: "deletedBy")
            try container.encodeIfPresent(demandPartnerManager, forKey: "demandPartnerManager")
            try container.encodeIfPresent(demandYieldManager, forKey: "demandYieldManager")
            try container.encodeIfPresent(supplyPartnerManager, forKey: "supplyPartnerManager")
            try container.encodeIfPresent(supplyYieldManager, forKey: "supplyYieldManager")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? AccountOwners else { return false }
          guard self.id == object.id else { return false }
          guard self.accountId == object.accountId else { return false }
          guard self.createdAt == object.createdAt else { return false }
          guard self.createdBy == object.createdBy else { return false }
          guard self.deletedAt == object.deletedAt else { return false }
          guard self.deletedBy == object.deletedBy else { return false }
          guard self.demandPartnerManager == object.demandPartnerManager else { return false }
          guard self.demandYieldManager == object.demandYieldManager else { return false }
          guard self.supplyPartnerManager == object.supplyPartnerManager else { return false }
          guard self.supplyYieldManager == object.supplyYieldManager else { return false }
          return true
        }

        public static func == (lhs: AccountOwners, rhs: AccountOwners) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(id: Int, uuid: ID, name: String, billingSetup: Bool, createdAt: DateTime, createdBy: ID, accountOwners: AccountOwners? = nil, address1: String? = nil, address2: String? = nil, address3: String? = nil, billingName: String? = nil, city: String? = nil, country: String? = nil, deactivatedAt: DateTime? = nil, deactivatedBy: ID? = nil, deletedAt: DateTime? = nil, deletedBy: ID? = nil, email: String? = nil, phoneNumber: String? = nil, receivableBillingName: String? = nil, state: String? = nil, zipcode: String? = nil) {
        self.id = id
        self.uuid = uuid
        self.name = name
        self.billingSetup = billingSetup
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.accountOwners = accountOwners
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.billingName = billingName
        self.city = city
        self.country = country
        self.deactivatedAt = deactivatedAt
        self.deactivatedBy = deactivatedBy
        self.deletedAt = deletedAt
        self.deletedBy = deletedBy
        self.email = email
        self.phoneNumber = phoneNumber
        self.receivableBillingName = receivableBillingName
        self.state = state
        self.zipcode = zipcode
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        id = try container.decode("id")
        uuid = try container.decode("uuid")
        name = try container.decode("name")
        billingSetup = try container.decode("billingSetup")
        createdAt = try container.decode("createdAt")
        createdBy = try container.decode("createdBy")
        accountOwners = try container.decodeIfPresent("accountOwners")
        address1 = try container.decodeIfPresent("address1")
        address2 = try container.decodeIfPresent("address2")
        address3 = try container.decodeIfPresent("address3")
        billingName = try container.decodeIfPresent("billingName")
        city = try container.decodeIfPresent("city")
        country = try container.decodeIfPresent("country")
        deactivatedAt = try container.decodeIfPresent("deactivatedAt")
        deactivatedBy = try container.decodeIfPresent("deactivatedBy")
        deletedAt = try container.decodeIfPresent("deletedAt")
        deletedBy = try container.decodeIfPresent("deletedBy")
        email = try container.decodeIfPresent("email")
        phoneNumber = try container.decodeIfPresent("phoneNumber")
        receivableBillingName = try container.decodeIfPresent("receivableBillingName")
        state = try container.decodeIfPresent("state")
        zipcode = try container.decodeIfPresent("zipcode")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encode(id, forKey: "id")
        try container.encode(uuid, forKey: "uuid")
        try container.encode(name, forKey: "name")
        try container.encode(billingSetup, forKey: "billingSetup")
        try container.encode(createdAt, forKey: "createdAt")
        try container.encode(createdBy, forKey: "createdBy")
        try container.encodeIfPresent(accountOwners, forKey: "accountOwners")
        try container.encodeIfPresent(address1, forKey: "address1")
        try container.encodeIfPresent(address2, forKey: "address2")
        try container.encodeIfPresent(address3, forKey: "address3")
        try container.encodeIfPresent(billingName, forKey: "billingName")
        try container.encodeIfPresent(city, forKey: "city")
        try container.encodeIfPresent(country, forKey: "country")
        try container.encodeIfPresent(deactivatedAt, forKey: "deactivatedAt")
        try container.encodeIfPresent(deactivatedBy, forKey: "deactivatedBy")
        try container.encodeIfPresent(deletedAt, forKey: "deletedAt")
        try container.encodeIfPresent(deletedBy, forKey: "deletedBy")
        try container.encodeIfPresent(email, forKey: "email")
        try container.encodeIfPresent(phoneNumber, forKey: "phoneNumber")
        try container.encodeIfPresent(receivableBillingName, forKey: "receivableBillingName")
        try container.encodeIfPresent(state, forKey: "state")
        try container.encodeIfPresent(zipcode, forKey: "zipcode")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? EvenAccount else { return false }
      guard self.id == object.id else { return false }
      guard self.uuid == object.uuid else { return false }
      guard self.name == object.name else { return false }
      guard self.billingSetup == object.billingSetup else { return false }
      guard self.createdAt == object.createdAt else { return false }
      guard self.createdBy == object.createdBy else { return false }
      guard self.accountOwners == object.accountOwners else { return false }
      guard self.address1 == object.address1 else { return false }
      guard self.address2 == object.address2 else { return false }
      guard self.address3 == object.address3 else { return false }
      guard self.billingName == object.billingName else { return false }
      guard self.city == object.city else { return false }
      guard self.country == object.country else { return false }
      guard self.deactivatedAt == object.deactivatedAt else { return false }
      guard self.deactivatedBy == object.deactivatedBy else { return false }
      guard self.deletedAt == object.deletedAt else { return false }
      guard self.deletedBy == object.deletedBy else { return false }
      guard self.email == object.email else { return false }
      guard self.phoneNumber == object.phoneNumber else { return false }
      guard self.receivableBillingName == object.receivableBillingName else { return false }
      guard self.state == object.state else { return false }
      guard self.zipcode == object.zipcode else { return false }
      return true
    }

    public static func == (lhs: EvenAccount, rhs: EvenAccount) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
