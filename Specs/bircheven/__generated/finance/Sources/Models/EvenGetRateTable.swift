//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** A `RateTable` customized to a `Lead` input */
public class EvenGetRateTable: BirchModel, Decodable, AutoEquatable {

    /** Primary UUID for a `RateTable` */
    public var uuid: ID

    /** UUID of the associated `Lead` */
    public var leadUuid: ID

    /** `Lead`'s provided loan amount at the time of `RateTable` creation */
    public var loanAmount: Int

    public var creditCardOffers: [CreditCardOffers]

    public var loanOffers: [LoanOffers]

    public var mortgageOffers: [MortgageOffers]

    public var savingsOffers: [SavingsOffers]

    public var specialOffers: [SpecialOffers]

    /** List of originators which have been queried, but have not responded yet. This list only contains loan originators, and should no longer be used */
    public var pendingOriginators: [PendingOriginators]

    /** List of demand partners which have been queried, but have not responded yet. It is a guarantee that no offers will be added to the rate table after this list is empty */
    public var pendingResponses: [PendingResponses]

    /** An offer for a credit card */
    public class CreditCardOffers: BirchModel, Decodable, AutoEquatable {

        public var details: Details

        /** An offer for a credit card */
        public class Details: BirchModel, Decodable, AutoEquatable {

            /** Benefits or benefit categories related to a credit card */
            public enum EvenCardBenefits: String, Codable, Equatable, CaseIterable {
                case noForeignTransactionFees = "No Foreign Transaction Fees"
                case purchaseProtection = "Purchase Protection"
                case returnProtection = "Return Protection"
                case priceProtection = "Price Protection"
                case fraudProtection = "Fraud Protection"
                case extendedWarranty = "Extended Warranty"
                case travelAccidentInsurance = "Travel Accident Insurance"
                case tripInterruptionInsurance = "Trip Interruption Insurance"
                case carRentalInsurance = "Car Rental Insurance"
                case baggageInsurance = "Baggage Insurance"
                case baggageDelayInsurance = "Baggage Delay Insurance"
                case hotelBurglaryInsurance = "Hotel Burglary Insurance"
                case travelandEmergencyAssistance = "Travel & Emergency Assistance"
                case roadsideAssistance = "Roadside Assistance"
                case conciergeService = "Concierge Service"
                case loungeAccess = "Lounge Access"
                case identityTheftAssistance = "Identity Theft Assistance"
                case inFlightSavings = "In-Flight Savings"
                case freeCheckedBag = "Free Checked Bag"
                case priorityBoarding = "Priority Boarding"
                case noBlackoutDates = "No Blackout Dates"
                case freeCompanionTicket = "Free Companion Ticket"
                case discountCompanionTicket = "Discount Companion Ticket"
                case globalEntryOrTSAPreCheck = "Global Entry or TSA PreCheck"
                case privateJetPerks = "Private Jet Perks"
                case loungeAccessDiscount = "Lounge Access Discount"
                case _247CardholderSupport = "24/7 Cardholder Support"
                case authorizedUser = "Authorized User"
                case entertainmentAccess = "Entertainment Access"
                case airlineFeeCredit = "Airline Fee Credit"
                case lateFeePass = "Late Fee Pass"
                case creditScoreReporting = "Credit Score Reporting"
                case noFlightChangeFees = "No Flight Change Fees"
                case _247AccountMonitoring = "24/7 Account Monitoring"
                case amexOffers = "Amex Offers"
                case visaSignatureOffers = "Visa Signature Offers"
                case masterCardOffers = "MasterCard Offers"
                case freeHotelStay = "Free Hotel Stay"
                case extendedHotelStay = "Extended Hotel Stay"
                case diningConcierge = "Dining Concierge"
                case _2LoungePasses = "2 Lounge Passes"
                case hiltonHonorsSilverMembership = "Hilton Honors Silver Membership"
                case hiltonHonorsGoldMembership = "Hilton Honors Gold Membership"
                case worldOfHyattDiscoveristStatus = "World of Hyatt Discoverist Status"
                case sPGGoldMembership = "SPG Gold Membership"
                case marriottRewardsSilverStatus = "Marriott Rewards Silver Status"
                case hertzPresidentsCircleEliteStatus = "Hertz Presidents Circle Elite Status"
                case _2FreeCheckedBags = "2 Free Checked Bags"
                case autoDiscounts = "Auto Discounts"
                case inCirclePartnership = "InCircle Partnership"
                case shopRunner = "ShopRunner"
                case wiFiAccess = "WiFi Access"
                case shopSafe = "ShopSafe"
                case boAPreferredRewards = "BoA Preferred Rewards"
                case masterCardFuelRewardsNetwork = "MasterCard Fuel Rewards Network"
                case missedEventTicketProtection = "Missed Event Ticket Protection"
                case accountFreezing = "Account Freezing"
                case cellPhoneProtection = "Cell Phone Protection"
                case gPARewards = "GPA Rewards"
                case inFlightWiFiCredit = "In-Flight WiFi Credit"
                case citiPrivatePass = "Citi Private Pass"
                case pricelessCities = "Priceless Cities"
                case theHotelCollection = "The Hotel Collection"
                case byInvitationOnly = "By Invitation Only"
                case luxuryHotelCollection = "Luxury Hotel Collection"
                case expediaSilverStatus = "Expedia+ Silver Status"
                case expediaGoldStatus = "Expedia+ Gold Status"
                case dollar100AmericanAirlinesDiscount = "$100 American Airlines Discount"
                case disneyParksPerksAndSavings = "Disney Parks Perks and Savings"
                case ritzCarltonGoldEliteStatus = "Ritz-Carlton Gold Elite Status"
                case ritzCarltonClubLevelUpgrade = "Ritz-Carlton Club Level Upgrade"
                case annualTravelCredit = "Annual Travel Credit"
                case iHGPlatinumEliteStatus = "IHG Platinum Elite Status"
                case quickBooksConnect = "QuickBooks Connect"
                case receiptMatch = "ReceiptMatch"
                case employeeSpendingLimits = "Employee Spending Limits"
                case fXInternationalPayments = "FX International Payments"
                case noPreSetSpendingLimit = "No Pre-Set Spending Limit"
                case purchaseFinancing = "Purchase Financing"
                case amexOpenSavings = "Amex Open Savings"
                case amazonSpecialFinancing = "Amazon Special Financing"
                case dollar100RitzCarltonHotelCredit = "$100 Ritz-Carlton Hotel Credit"
                case britishAirwaysCompanionTicket = "British Airways Companion Ticket"
                case mercedesBenzGiftCertificates = "Mercedes-Benz Gift Certificates"
                case mercedesBenzExcessMileageWaiver = "Mercedes-Benz Excess Mileage Waiver"
                case jetBlueAnnualStatementCredit = "JetBlue Annual Statement Credit"
                case _20percentDiscountOnDeltaFlightsForDeltaPrivateJetMembers = "20% Discount on Delta Flights for Delta Private Jet Members"
                case expenseReportFeatures = "Expense Report Features"
                case businessCellPhoneProtection = "Business Cell Phone Protection"
                case freeShippingOnMostTargetComOrders = "Free Shipping on most Target.com orders"
                case _30ExtraDaysForReturns = "30 Extra Days for Returns"
                case freeClothingAltertaions = "Free clothing altertaions"
                case personalShopping = "Personal shopping"
                case shopmywaySavings = "Shopmyway Savings"
                case onlineSubscriptionCredit = "Online Subscription Credit"
                case uberExclusiveAccess = "Uber Exclusive Access"
                case airlineBenefits = "Airline Benefits"
                case hotelBenefits = "Hotel Benefits"
                case otherTravelBenefits = "Other Travel Benefits"
                case emergencyAssistance = "Emergency Assistance"
                case experiences = "Experiences"
                case shoppingBenefits = "Shopping Benefits"
                case cardholderBenefits = "Cardholder Benefits"
                case enhancedSecurity = "Enhanced Security"
                case businessBenefits = "Business Benefits"
                case otherBenefits = "Other Benefits"
                case inFlightDiscounts = "In-Flight Discounts"
                case feeCoverage = "Fee Coverage"
                case flightCreditsandDiscounts = "Flight Credits & Discounts"
                case hotelMembershipStatus = "Hotel Membership Status"
                case hotelCreditandFreeStays = "Hotel Credit & Free Stays"
                case travelCredit = "Travel Credit"
                case travelExperiencesPrograms = "Travel Experiences Programs"
                case carRentalMembershipStatus = "Car Rental Membership Status"
                case extraGasRewards = "Extra Gas Rewards"
                case shoppingProtection = "Shopping Protection"
                case shoppingDiscounts = "Shopping Discounts"
                case freeShipping = "Free Shipping"
                case theBoingoAmericanExpressPreferredPlan = "The Boingo American Express Preferred Plan"
                case airSpaceLounge = "AirSpace Lounge"
                case uberMonthlyCredit = "Uber Monthly Credit"
                case rideShareBenefits = "Ride Share Benefits"
                case deltaSkyClub = "Delta Sky Club"
                case admiralsClubMembership = "Admirals Club Membership"
                case priorityPassSelectMembershipPrestige = "Priority Pass Select Membership (Prestige)"
                case priorityPassSelectMembershipStandardPlus = "Priority Pass Select Membership (Standard Plus)"
                case dailyBreakfast = "Daily Breakfast"
                case earlyCheckInandLateCheckOut = "Early Check-in & Late Check-out"
                case roomUpgrades = "Room Upgrades"
                case complementaryWiFi = "Complementary WiFi"
                case amexHotelCollectionCredit = "Amex Hotel Collection Credit"
                case temporaryAccountNumbers = "Temporary Account Numbers"
                case oneTime50percentDiscountOnCompanionTicket = "One-Time 50% Discount on Companion Ticket"
                case airlineTravelCredit = "Airline Travel Credit"
                case unitedClubMembership = "United Club Membership"
                case chipTechnology = "Chip Technology"
                case earnMoreMilesForSharingTravelStories = "Earn More Miles for Sharing Travel Stories"
                case mastercardWorldEliteConciergeAndLuxuryTravelBenefits = "Mastercard World Elite Concierge and Luxury Travel Benefits"
                case _20percentSavingsOnDeltaInFlightPurchases = "20% Savings on Delta In-Flight Purchases"
                case _25percentSavingsOnUnitedInFlightFoodAndDrinkPurchases = "25% Savings on United In-Flight Food and Drink Purchases"
                case dollar100HiltonPropertiesCredit = "$100 Hilton Properties Credit"
                case dollar250HiltonResortCredit = "$250 Hilton Resort Credit"
                case hiltonHonorsDiamondMembership = "Hilton Honors Diamond Membership"
                case freeBirthdayGift = "Free Birthday Gift"
                case _2xPointsDuringYourBirthdayMonth = "2x Points During Your Birthday Month"
                case carRentalVIPPerks = "Car Rental VIP Perks"
                case freeShippingWithThePurchaseOfaBra = "Free shipping with the purchase of a bra"
                case monthlyDiningCredit = "Monthly Dining Credit"
                case amazonPrimeStudent = "Amazon Prime Student"
                case undecodable

                public init(from decoder: Decoder) throws {
                    let container = try decoder.singleValueContainer()
                    let rawValue = try container.decode(String.self)
                    self = EvenCardBenefits(rawValue: rawValue) ?? .undecodable
                }
            }

            /** An offer for a credit card */
            public enum EvenCardType: String, Codable, Equatable, CaseIterable {
                case visa = "visa"
                case mastercard = "mastercard"
                case americanExpress = "american_express"
                case discover = "discover"
                case undecodable

                public init(from decoder: Decoder) throws {
                    let container = try decoder.singleValueContainer()
                    let rawValue = try container.decode(String.self)
                    self = EvenCardType(rawValue: rawValue) ?? .undecodable
                }
            }

            /** An offer for a credit card */
            public enum EvenIntroOfferType: String, Codable, Equatable, CaseIterable {
                case miles = "miles"
                case points = "points"
                case statementCredit = "statement_credit"
                case undecodable

                public init(from decoder: Decoder) throws {
                    let container = try decoder.singleValueContainer()
                    let rawValue = try container.decode(String.self)
                    self = EvenIntroOfferType(rawValue: rawValue) ?? .undecodable
                }
            }

            public var cardImageUrl: String

            public var preQualified: Bool

            public var preApproved: Bool

            public var accountOpeningFee: Double?

            /** List of card features which must be displayed with the offer */
            public var additionalDetails: [String]?

            public var annualIntroFee: Double?

            /** Number of _years_ the introductory anual fee is in effect */
            public var annualIntroFeeTerm: Int?

            public var balanceTransferAprText: String?

            public var balanceTransferFee: Double?

            public var balanceTransferIntroAprTerm: Int?

            public var balanceTransferIntroAprTermUnit: EvenTermUnit?

            public var balanceTransferIntroAprText: String?

            public var cardBenefits: [EvenCardBenefits]?

            /** Display name of the card */
            public var cardName: String?

            public var cardPurposes: [EvenItems]?

            public var cardType: EvenCardType?

            public var cashAdvanceAprText: String?

            public var cashAdvanceFee: Double?

            public var cashAdvanceIntroAprTerm: Int?

            public var cashAdvanceIntroAprTermUnit: EvenTermUnit?

            public var cashAdvanceIntroAprText: String?

            /** List of card features which must be prominently displayed with the offer */
            public var details: [String]?

            /** Reward earning data for the card */
            public var earningProgram: EarningProgram?

            public var foreignExchangeFee: Double?

            /** Percentage represented in decimal format added to all foreign transactions */
            public var foreignTransactionFee: Float?

            public var introOfferAmount: Double?

            public var introOfferText: String?

            public var introOfferType: EvenIntroOfferType?

            public var lateFee: Double?

            public var maxAnnualFee: Double?

            public var maxBalanceTransferApr: Double?

            public var maxBalanceTransferIntroApr: Double?

            public var maxCashAdvanceApr: Double?

            public var maxCashAdvanceIntroApr: Double?

            public var maxPurchaseApr: Double?

            public var maxPurchaseIntroApr: Double?

            public var maximumPenaltyApr: Double?

            public var minAnnualFee: Double?

            public var minBalanceTransferApr: Double?

            public var minBalanceTransferIntroApr: Double?

            public var minCashAdvanceApr: Double?

            public var minCashAdvanceIntroApr: Double?

            public var minPurchaseApr: Double?

            public var minPurchaseIntroApr: Double?

            public var minimumCreditLine: Double?

            public var minimumPenaltyApr: Double?

            public var monthlyServiceFee: Double?

            /** Indicates that Even has determined that the user has an increased likelihood of being approved for this card. */
            public var preSelected: Bool?

            public var purchaseAprText: String?

            public var purchaseIntroAprTerm: Int?

            public var purchaseIntroAprTermUnit: EvenTermUnit?

            public var purchaseIntroAprText: String?

            /** External link to card rates, terms and conditions */
            public var ratesUrl: String?

            public var recommendedCreditRatings: [EvenProvidedCreditRating]?

            public var returnPaymentFee: Double?

            /** Reward earning data for the card */
            public class EarningProgram: BirchModel, Decodable, AutoEquatable {

                /** Grouped by earn rate, the rules that earn multipliers on each transaction */
                public var transactionLevelEarningScheme: [TransactionLevelEarningScheme]

                /** Card level bonuses, such as sign-on and anniversary bonuses */
                public var cardLevelEarningScheme: [CardLevelEarningScheme]

                /** Annual value of this card for the user, only returned in a simulation */
                public var personalization: Personalization?

                /** A context around a nuumber of earning groups, such as caps, tiers, etc */
                public class TransactionLevelEarningScheme: BirchModel, Decodable, AutoEquatable {

                    /** The type of context this is. Basic contexts have no details. */
                    public enum EvenType: String, Codable, Equatable, CaseIterable {
                        case basic = "basic"
                        case calculation = "calculation"
                        case introductory = "introductory"
                        case rotating = "rotating"
                        case capped = "capped"
                        case undecodable

                        public init(from decoder: Decoder) throws {
                            let container = try decoder.singleValueContainer()
                            let rawValue = try container.decode(String.self)
                            self = EvenType(rawValue: rawValue) ?? .undecodable
                        }
                    }

                    /** The earning groups relevent in this context */
                    public var groups: [Groups]

                    /** The type of context this is. Basic contexts have no details. */
                    public var type: EvenType

                    /** A phrase describing the context around the earning groups */
                    public var detail: String?

                    /** A full sentence describing the context around the earning groups */
                    public var explaination: String?

                    /** Personalized values calculated for a specific item, such as an earning group or bonus */
                    public var personalization: Personalization?

                    /** A group of qualifiers which share the same default earn rate */
                    public class Groups: BirchModel, Decodable, AutoEquatable {

                        /** Numerical representation of the earn rate for this group */
                        public var earnRate: Double

                        /** Display text for what the group earns */
                        public var earnRateText: String

                        public var items: [Items]

                        public var personalization: EvenPersonalization?

                        /** An association of an earn rate and a qualifier, like a category or merchant */
                        public class Items: BirchModel, Decodable, AutoEquatable {

                            /** Refers to the type (and schema) of the item */
                            public enum EvenType: String, Codable, Equatable, CaseIterable {
                                case category = "category"
                                case merchant = "merchant"
                                case ebp = "ebp"
                                case paymentMethod = "paymentMethod"
                                case undecodable

                                public init(from decoder: Decoder) throws {
                                    let container = try decoder.singleValueContainer()
                                    let rawValue = try container.decode(String.self)
                                    self = EvenType(rawValue: rawValue) ?? .undecodable
                                }
                            }

                            /** Refers to the type (and schema) of the item */
                            public var type: EvenType

                            /** A Category */
                            public var category: Category?

                            /** Numerical representation of the default earn rate per dollar spent of the item */
                            public var earnRate: Double?

                            /** A business or store that is affiliated with a credit card earning program */
                            public var merchant: Merchant?

                            public var personalization: EvenPersonalization?

                            /** A Category */
                            public class Category: BirchModel, Decodable, AutoEquatable {

                                /** A more user friendly name for the category */
                                public var displayName: String?

                                /** A detailed name for the category */
                                public var name: String?

                                /** Sentence friendly */
                                public var phrase: String?

                                public var uuid: ID?

                                public init(displayName: String? = nil, name: String? = nil, phrase: String? = nil, uuid: ID? = nil) {
                                    self.displayName = displayName
                                    self.name = name
                                    self.phrase = phrase
                                    self.uuid = uuid
                                }

                                public required init(from decoder: Decoder) throws {
                                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                                    displayName = try container.decodeIfPresent("displayName")
                                    name = try container.decodeIfPresent("name")
                                    phrase = try container.decodeIfPresent("phrase")
                                    uuid = try container.decodeIfPresent("uuid")
                                }

                                public func encode(to encoder: Encoder) throws {
                                    var container = encoder.container(keyedBy: StringCodingKey.self)

                                    try container.encodeIfPresent(displayName, forKey: "displayName")
                                    try container.encodeIfPresent(name, forKey: "name")
                                    try container.encodeIfPresent(phrase, forKey: "phrase")
                                    try container.encodeIfPresent(uuid, forKey: "uuid")
                                }

                                public func isEqual(to object: Any?) -> Bool {
                                  guard let object = object as? Category else { return false }
                                  guard self.displayName == object.displayName else { return false }
                                  guard self.name == object.name else { return false }
                                  guard self.phrase == object.phrase else { return false }
                                  guard self.uuid == object.uuid else { return false }
                                  return true
                                }

                                public static func == (lhs: Category, rhs: Category) -> Bool {
                                    return lhs.isEqual(to: rhs)
                                }
                            }

                            /** A business or store that is affiliated with a credit card earning program */
                            public class Merchant: BirchModel, Decodable, AutoEquatable {

                                public var category: EvenCategory?

                                /** Logo URL */
                                public var logo: String?

                                /** The merchant's name */
                                public var name: String?

                                public var uuid: ID?

                                public init(category: EvenCategory? = nil, logo: String? = nil, name: String? = nil, uuid: ID? = nil) {
                                    self.category = category
                                    self.logo = logo
                                    self.name = name
                                    self.uuid = uuid
                                }

                                public required init(from decoder: Decoder) throws {
                                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                                    category = try container.decodeIfPresent("category")
                                    logo = try container.decodeIfPresent("logo")
                                    name = try container.decodeIfPresent("name")
                                    uuid = try container.decodeIfPresent("uuid")
                                }

                                public func encode(to encoder: Encoder) throws {
                                    var container = encoder.container(keyedBy: StringCodingKey.self)

                                    try container.encodeIfPresent(category, forKey: "category")
                                    try container.encodeIfPresent(logo, forKey: "logo")
                                    try container.encodeIfPresent(name, forKey: "name")
                                    try container.encodeIfPresent(uuid, forKey: "uuid")
                                }

                                public func isEqual(to object: Any?) -> Bool {
                                  guard let object = object as? Merchant else { return false }
                                  guard self.category == object.category else { return false }
                                  guard self.logo == object.logo else { return false }
                                  guard self.name == object.name else { return false }
                                  guard self.uuid == object.uuid else { return false }
                                  return true
                                }

                                public static func == (lhs: Merchant, rhs: Merchant) -> Bool {
                                    return lhs.isEqual(to: rhs)
                                }
                            }

                            public init(type: EvenType, category: Category? = nil, earnRate: Double? = nil, merchant: Merchant? = nil, personalization: EvenPersonalization? = nil) {
                                self.type = type
                                self.category = category
                                self.earnRate = earnRate
                                self.merchant = merchant
                                self.personalization = personalization
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: StringCodingKey.self)

                                type = try container.decode("type")
                                category = try container.decodeIfPresent("category")
                                earnRate = try container.decodeIfPresent("earnRate")
                                merchant = try container.decodeIfPresent("merchant")
                                personalization = try container.decodeIfPresent("personalization")
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: StringCodingKey.self)

                                try container.encode(type, forKey: "type")
                                try container.encodeIfPresent(category, forKey: "category")
                                try container.encodeIfPresent(earnRate, forKey: "earnRate")
                                try container.encodeIfPresent(merchant, forKey: "merchant")
                                try container.encodeIfPresent(personalization, forKey: "personalization")
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? Items else { return false }
                              guard self.type == object.type else { return false }
                              guard self.category == object.category else { return false }
                              guard self.earnRate == object.earnRate else { return false }
                              guard self.merchant == object.merchant else { return false }
                              guard self.personalization == object.personalization else { return false }
                              return true
                            }

                            public static func == (lhs: Items, rhs: Items) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        public init(earnRate: Double, earnRateText: String, items: [Items], personalization: EvenPersonalization? = nil) {
                            self.earnRate = earnRate
                            self.earnRateText = earnRateText
                            self.items = items
                            self.personalization = personalization
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            earnRate = try container.decode("earnRate")
                            earnRateText = try container.decode("earnRateText")
                            items = try container.decodeArray("items")
                            personalization = try container.decodeIfPresent("personalization")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encode(earnRate, forKey: "earnRate")
                            try container.encode(earnRateText, forKey: "earnRateText")
                            try container.encode(items, forKey: "items")
                            try container.encodeIfPresent(personalization, forKey: "personalization")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Groups else { return false }
                          guard self.earnRate == object.earnRate else { return false }
                          guard self.earnRateText == object.earnRateText else { return false }
                          guard self.items == object.items else { return false }
                          guard self.personalization == object.personalization else { return false }
                          return true
                        }

                        public static func == (lhs: Groups, rhs: Groups) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** Personalized values calculated for a specific item, such as an earning group or bonus */
                    public class Personalization: BirchModel, Decodable, AutoEquatable {

                        /** The amount of points/miles/dollars the user would have received within a calendar year */
                        public var totalEarned: Double?

                        /** The amount the user spent in dollars within a calendar year */
                        public var totalSpent: Double?

                        /** The value in USD of the totalEarned amount based on the user's custom point valuation */
                        public var totalValue: Double?

                        public init(totalEarned: Double? = nil, totalSpent: Double? = nil, totalValue: Double? = nil) {
                            self.totalEarned = totalEarned
                            self.totalSpent = totalSpent
                            self.totalValue = totalValue
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            totalEarned = try container.decodeIfPresent("totalEarned")
                            totalSpent = try container.decodeIfPresent("totalSpent")
                            totalValue = try container.decodeIfPresent("totalValue")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(totalEarned, forKey: "totalEarned")
                            try container.encodeIfPresent(totalSpent, forKey: "totalSpent")
                            try container.encodeIfPresent(totalValue, forKey: "totalValue")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Personalization else { return false }
                          guard self.totalEarned == object.totalEarned else { return false }
                          guard self.totalSpent == object.totalSpent else { return false }
                          guard self.totalValue == object.totalValue else { return false }
                          return true
                        }

                        public static func == (lhs: Personalization, rhs: Personalization) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(groups: [Groups], type: EvenType, detail: String? = nil, explaination: String? = nil, personalization: Personalization? = nil) {
                        self.groups = groups
                        self.type = type
                        self.detail = detail
                        self.explaination = explaination
                        self.personalization = personalization
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        groups = try container.decodeArray("groups")
                        type = try container.decode("type")
                        detail = try container.decodeIfPresent("detail")
                        explaination = try container.decodeIfPresent("explaination")
                        personalization = try container.decodeIfPresent("personalization")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encode(groups, forKey: "groups")
                        try container.encode(type, forKey: "type")
                        try container.encodeIfPresent(detail, forKey: "detail")
                        try container.encodeIfPresent(explaination, forKey: "explaination")
                        try container.encodeIfPresent(personalization, forKey: "personalization")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? TransactionLevelEarningScheme else { return false }
                      guard self.groups == object.groups else { return false }
                      guard self.type == object.type else { return false }
                      guard self.detail == object.detail else { return false }
                      guard self.explaination == object.explaination else { return false }
                      guard self.personalization == object.personalization else { return false }
                      return true
                    }

                    public static func == (lhs: TransactionLevelEarningScheme, rhs: TransactionLevelEarningScheme) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** An earning event which is based on spend or is over time */
                public class CardLevelEarningScheme: BirchModel, Decodable, AutoEquatable {

                    /** An earning event which is based on spend or is over time */
                    public enum EvenType: String, Codable, Equatable, CaseIterable {
                        case oneTime = "One Time"
                        case recurring = "Recurring"
                        case undecodable

                        public init(from decoder: Decoder) throws {
                            let container = try decoder.singleValueContainer()
                            let rawValue = try container.decode(String.self)
                            self = EvenType(rawValue: rawValue) ?? .undecodable
                        }
                    }

                    /** An earning event which is based on spend or is over time */
                    public enum EvenName: String, Codable, Equatable, CaseIterable {
                        case signUpBonus = "Sign-Up Bonus"
                        case anniversaryBonus = "Anniversary Bonus"
                        case annualBonus = "Annual Bonus"
                        case usageBonus = "Usage Bonus"
                        case undecodable

                        public init(from decoder: Decoder) throws {
                            let container = try decoder.singleValueContainer()
                            let rawValue = try container.decode(String.self)
                            self = EvenName(rawValue: rawValue) ?? .undecodable
                        }
                    }

                    public var type: EvenType

                    public var name: EvenName

                    public var bonus: String

                    public var redemptionValue: String

                    public var requirement: String

                    /** Personalized values calculated for a specific bonus, such as a Sign On Bonus */
                    public var personalization: Personalization?

                    /** Personalized values calculated for a specific bonus, such as a Sign On Bonus */
                    public class Personalization: BirchModel, Decodable, AutoEquatable {

                        /** Were the conditions of the bonus met */
                        public var minimumSpendMet: Bool?

                        /** The amount of spend the user had within the time period of the bonus */
                        public var qualifyingSpend: String?

                        public init(minimumSpendMet: Bool? = nil, qualifyingSpend: String? = nil) {
                            self.minimumSpendMet = minimumSpendMet
                            self.qualifyingSpend = qualifyingSpend
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            minimumSpendMet = try container.decodeIfPresent("minimumSpendMet")
                            qualifyingSpend = try container.decodeIfPresent("qualifyingSpend")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(minimumSpendMet, forKey: "minimumSpendMet")
                            try container.encodeIfPresent(qualifyingSpend, forKey: "qualifyingSpend")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Personalization else { return false }
                          guard self.minimumSpendMet == object.minimumSpendMet else { return false }
                          guard self.qualifyingSpend == object.qualifyingSpend else { return false }
                          return true
                        }

                        public static func == (lhs: Personalization, rhs: Personalization) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(type: EvenType, name: EvenName, bonus: String, redemptionValue: String, requirement: String, personalization: Personalization? = nil) {
                        self.type = type
                        self.name = name
                        self.bonus = bonus
                        self.redemptionValue = redemptionValue
                        self.requirement = requirement
                        self.personalization = personalization
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        type = try container.decode("type")
                        name = try container.decode("name")
                        bonus = try container.decode("bonus")
                        redemptionValue = try container.decode("redemptionValue")
                        requirement = try container.decode("requirement")
                        personalization = try container.decodeIfPresent("personalization")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encode(type, forKey: "type")
                        try container.encode(name, forKey: "name")
                        try container.encode(bonus, forKey: "bonus")
                        try container.encode(redemptionValue, forKey: "redemptionValue")
                        try container.encode(requirement, forKey: "requirement")
                        try container.encodeIfPresent(personalization, forKey: "personalization")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? CardLevelEarningScheme else { return false }
                      guard self.type == object.type else { return false }
                      guard self.name == object.name else { return false }
                      guard self.bonus == object.bonus else { return false }
                      guard self.redemptionValue == object.redemptionValue else { return false }
                      guard self.requirement == object.requirement else { return false }
                      guard self.personalization == object.personalization else { return false }
                      return true
                    }

                    public static func == (lhs: CardLevelEarningScheme, rhs: CardLevelEarningScheme) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** Annual value of this card for the user, only returned in a simulation */
                public class Personalization: BirchModel, Decodable, AutoEquatable {

                    /** The amount of points/miles/dollars the user would have received within a calendar year */
                    public var totalEarned: Double?

                    /** The amount the user spent in dollars within a calendar year */
                    public var totalSpent: Double?

                    /** The value in USD of the totalEarned amount based on the user's custom point valuation, minus fees */
                    public var totalValue: Double?

                    public init(totalEarned: Double? = nil, totalSpent: Double? = nil, totalValue: Double? = nil) {
                        self.totalEarned = totalEarned
                        self.totalSpent = totalSpent
                        self.totalValue = totalValue
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        totalEarned = try container.decodeIfPresent("totalEarned")
                        totalSpent = try container.decodeIfPresent("totalSpent")
                        totalValue = try container.decodeIfPresent("totalValue")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(totalEarned, forKey: "totalEarned")
                        try container.encodeIfPresent(totalSpent, forKey: "totalSpent")
                        try container.encodeIfPresent(totalValue, forKey: "totalValue")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Personalization else { return false }
                      guard self.totalEarned == object.totalEarned else { return false }
                      guard self.totalSpent == object.totalSpent else { return false }
                      guard self.totalValue == object.totalValue else { return false }
                      return true
                    }

                    public static func == (lhs: Personalization, rhs: Personalization) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(transactionLevelEarningScheme: [TransactionLevelEarningScheme], cardLevelEarningScheme: [CardLevelEarningScheme], personalization: Personalization? = nil) {
                    self.transactionLevelEarningScheme = transactionLevelEarningScheme
                    self.cardLevelEarningScheme = cardLevelEarningScheme
                    self.personalization = personalization
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    transactionLevelEarningScheme = try container.decodeArray("transactionLevelEarningScheme")
                    cardLevelEarningScheme = try container.decodeArray("cardLevelEarningScheme")
                    personalization = try container.decodeIfPresent("personalization")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(transactionLevelEarningScheme, forKey: "transactionLevelEarningScheme")
                    try container.encode(cardLevelEarningScheme, forKey: "cardLevelEarningScheme")
                    try container.encodeIfPresent(personalization, forKey: "personalization")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? EarningProgram else { return false }
                  guard self.transactionLevelEarningScheme == object.transactionLevelEarningScheme else { return false }
                  guard self.cardLevelEarningScheme == object.cardLevelEarningScheme else { return false }
                  guard self.personalization == object.personalization else { return false }
                  return true
                }

                public static func == (lhs: EarningProgram, rhs: EarningProgram) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public init(cardImageUrl: String, preQualified: Bool, preApproved: Bool, accountOpeningFee: Double? = nil, additionalDetails: [String]? = nil, annualIntroFee: Double? = nil, annualIntroFeeTerm: Int? = nil, balanceTransferAprText: String? = nil, balanceTransferFee: Double? = nil, balanceTransferIntroAprTerm: Int? = nil, balanceTransferIntroAprTermUnit: EvenTermUnit? = nil, balanceTransferIntroAprText: String? = nil, cardBenefits: [EvenCardBenefits]? = nil, cardName: String? = nil, cardPurposes: [EvenItems]? = nil, cardType: EvenCardType? = nil, cashAdvanceAprText: String? = nil, cashAdvanceFee: Double? = nil, cashAdvanceIntroAprTerm: Int? = nil, cashAdvanceIntroAprTermUnit: EvenTermUnit? = nil, cashAdvanceIntroAprText: String? = nil, details: [String]? = nil, earningProgram: EarningProgram? = nil, foreignExchangeFee: Double? = nil, foreignTransactionFee: Float? = nil, introOfferAmount: Double? = nil, introOfferText: String? = nil, introOfferType: EvenIntroOfferType? = nil, lateFee: Double? = nil, maxAnnualFee: Double? = nil, maxBalanceTransferApr: Double? = nil, maxBalanceTransferIntroApr: Double? = nil, maxCashAdvanceApr: Double? = nil, maxCashAdvanceIntroApr: Double? = nil, maxPurchaseApr: Double? = nil, maxPurchaseIntroApr: Double? = nil, maximumPenaltyApr: Double? = nil, minAnnualFee: Double? = nil, minBalanceTransferApr: Double? = nil, minBalanceTransferIntroApr: Double? = nil, minCashAdvanceApr: Double? = nil, minCashAdvanceIntroApr: Double? = nil, minPurchaseApr: Double? = nil, minPurchaseIntroApr: Double? = nil, minimumCreditLine: Double? = nil, minimumPenaltyApr: Double? = nil, monthlyServiceFee: Double? = nil, preSelected: Bool? = nil, purchaseAprText: String? = nil, purchaseIntroAprTerm: Int? = nil, purchaseIntroAprTermUnit: EvenTermUnit? = nil, purchaseIntroAprText: String? = nil, ratesUrl: String? = nil, recommendedCreditRatings: [EvenProvidedCreditRating]? = nil, returnPaymentFee: Double? = nil) {
                self.cardImageUrl = cardImageUrl
                self.preQualified = preQualified
                self.preApproved = preApproved
                self.accountOpeningFee = accountOpeningFee
                self.additionalDetails = additionalDetails
                self.annualIntroFee = annualIntroFee
                self.annualIntroFeeTerm = annualIntroFeeTerm
                self.balanceTransferAprText = balanceTransferAprText
                self.balanceTransferFee = balanceTransferFee
                self.balanceTransferIntroAprTerm = balanceTransferIntroAprTerm
                self.balanceTransferIntroAprTermUnit = balanceTransferIntroAprTermUnit
                self.balanceTransferIntroAprText = balanceTransferIntroAprText
                self.cardBenefits = cardBenefits
                self.cardName = cardName
                self.cardPurposes = cardPurposes
                self.cardType = cardType
                self.cashAdvanceAprText = cashAdvanceAprText
                self.cashAdvanceFee = cashAdvanceFee
                self.cashAdvanceIntroAprTerm = cashAdvanceIntroAprTerm
                self.cashAdvanceIntroAprTermUnit = cashAdvanceIntroAprTermUnit
                self.cashAdvanceIntroAprText = cashAdvanceIntroAprText
                self.details = details
                self.earningProgram = earningProgram
                self.foreignExchangeFee = foreignExchangeFee
                self.foreignTransactionFee = foreignTransactionFee
                self.introOfferAmount = introOfferAmount
                self.introOfferText = introOfferText
                self.introOfferType = introOfferType
                self.lateFee = lateFee
                self.maxAnnualFee = maxAnnualFee
                self.maxBalanceTransferApr = maxBalanceTransferApr
                self.maxBalanceTransferIntroApr = maxBalanceTransferIntroApr
                self.maxCashAdvanceApr = maxCashAdvanceApr
                self.maxCashAdvanceIntroApr = maxCashAdvanceIntroApr
                self.maxPurchaseApr = maxPurchaseApr
                self.maxPurchaseIntroApr = maxPurchaseIntroApr
                self.maximumPenaltyApr = maximumPenaltyApr
                self.minAnnualFee = minAnnualFee
                self.minBalanceTransferApr = minBalanceTransferApr
                self.minBalanceTransferIntroApr = minBalanceTransferIntroApr
                self.minCashAdvanceApr = minCashAdvanceApr
                self.minCashAdvanceIntroApr = minCashAdvanceIntroApr
                self.minPurchaseApr = minPurchaseApr
                self.minPurchaseIntroApr = minPurchaseIntroApr
                self.minimumCreditLine = minimumCreditLine
                self.minimumPenaltyApr = minimumPenaltyApr
                self.monthlyServiceFee = monthlyServiceFee
                self.preSelected = preSelected
                self.purchaseAprText = purchaseAprText
                self.purchaseIntroAprTerm = purchaseIntroAprTerm
                self.purchaseIntroAprTermUnit = purchaseIntroAprTermUnit
                self.purchaseIntroAprText = purchaseIntroAprText
                self.ratesUrl = ratesUrl
                self.recommendedCreditRatings = recommendedCreditRatings
                self.returnPaymentFee = returnPaymentFee
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                cardImageUrl = try container.decode("cardImageUrl")
                preQualified = try container.decode("preQualified")
                preApproved = try container.decode("preApproved")
                accountOpeningFee = try container.decodeIfPresent("accountOpeningFee")
                additionalDetails = try container.decodeArrayIfPresent("additionalDetails")
                annualIntroFee = try container.decodeIfPresent("annualIntroFee")
                annualIntroFeeTerm = try container.decodeIfPresent("annualIntroFeeTerm")
                balanceTransferAprText = try container.decodeIfPresent("balanceTransferAprText")
                balanceTransferFee = try container.decodeIfPresent("balanceTransferFee")
                balanceTransferIntroAprTerm = try container.decodeIfPresent("balanceTransferIntroAprTerm")
                balanceTransferIntroAprTermUnit = try container.decodeIfPresent("balanceTransferIntroAprTermUnit")
                balanceTransferIntroAprText = try container.decodeIfPresent("balanceTransferIntroAprText")
                cardBenefits = try container.decodeArrayIfPresent("cardBenefits")
                cardName = try container.decodeIfPresent("cardName")
                cardPurposes = try container.decodeArrayIfPresent("cardPurposes")
                cardType = try container.decodeIfPresent("cardType")
                cashAdvanceAprText = try container.decodeIfPresent("cashAdvanceAprText")
                cashAdvanceFee = try container.decodeIfPresent("cashAdvanceFee")
                cashAdvanceIntroAprTerm = try container.decodeIfPresent("cashAdvanceIntroAprTerm")
                cashAdvanceIntroAprTermUnit = try container.decodeIfPresent("cashAdvanceIntroAprTermUnit")
                cashAdvanceIntroAprText = try container.decodeIfPresent("cashAdvanceIntroAprText")
                details = try container.decodeArrayIfPresent("details")
                earningProgram = try container.decodeIfPresent("earningProgram")
                foreignExchangeFee = try container.decodeIfPresent("foreignExchangeFee")
                foreignTransactionFee = try container.decodeIfPresent("foreignTransactionFee")
                introOfferAmount = try container.decodeIfPresent("introOfferAmount")
                introOfferText = try container.decodeIfPresent("introOfferText")
                introOfferType = try container.decodeIfPresent("introOfferType")
                lateFee = try container.decodeIfPresent("lateFee")
                maxAnnualFee = try container.decodeIfPresent("maxAnnualFee")
                maxBalanceTransferApr = try container.decodeIfPresent("maxBalanceTransferApr")
                maxBalanceTransferIntroApr = try container.decodeIfPresent("maxBalanceTransferIntroApr")
                maxCashAdvanceApr = try container.decodeIfPresent("maxCashAdvanceApr")
                maxCashAdvanceIntroApr = try container.decodeIfPresent("maxCashAdvanceIntroApr")
                maxPurchaseApr = try container.decodeIfPresent("maxPurchaseApr")
                maxPurchaseIntroApr = try container.decodeIfPresent("maxPurchaseIntroApr")
                maximumPenaltyApr = try container.decodeIfPresent("maximumPenaltyApr")
                minAnnualFee = try container.decodeIfPresent("minAnnualFee")
                minBalanceTransferApr = try container.decodeIfPresent("minBalanceTransferApr")
                minBalanceTransferIntroApr = try container.decodeIfPresent("minBalanceTransferIntroApr")
                minCashAdvanceApr = try container.decodeIfPresent("minCashAdvanceApr")
                minCashAdvanceIntroApr = try container.decodeIfPresent("minCashAdvanceIntroApr")
                minPurchaseApr = try container.decodeIfPresent("minPurchaseApr")
                minPurchaseIntroApr = try container.decodeIfPresent("minPurchaseIntroApr")
                minimumCreditLine = try container.decodeIfPresent("minimumCreditLine")
                minimumPenaltyApr = try container.decodeIfPresent("minimumPenaltyApr")
                monthlyServiceFee = try container.decodeIfPresent("monthlyServiceFee")
                preSelected = try container.decodeIfPresent("preSelected")
                purchaseAprText = try container.decodeIfPresent("purchaseAprText")
                purchaseIntroAprTerm = try container.decodeIfPresent("purchaseIntroAprTerm")
                purchaseIntroAprTermUnit = try container.decodeIfPresent("purchaseIntroAprTermUnit")
                purchaseIntroAprText = try container.decodeIfPresent("purchaseIntroAprText")
                ratesUrl = try container.decodeIfPresent("ratesUrl")
                recommendedCreditRatings = try container.decodeArrayIfPresent("recommendedCreditRatings")
                returnPaymentFee = try container.decodeIfPresent("returnPaymentFee")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encode(cardImageUrl, forKey: "cardImageUrl")
                try container.encode(preQualified, forKey: "preQualified")
                try container.encode(preApproved, forKey: "preApproved")
                try container.encodeIfPresent(accountOpeningFee, forKey: "accountOpeningFee")
                try container.encodeIfPresent(additionalDetails, forKey: "additionalDetails")
                try container.encodeIfPresent(annualIntroFee, forKey: "annualIntroFee")
                try container.encodeIfPresent(annualIntroFeeTerm, forKey: "annualIntroFeeTerm")
                try container.encodeIfPresent(balanceTransferAprText, forKey: "balanceTransferAprText")
                try container.encodeIfPresent(balanceTransferFee, forKey: "balanceTransferFee")
                try container.encodeIfPresent(balanceTransferIntroAprTerm, forKey: "balanceTransferIntroAprTerm")
                try container.encodeIfPresent(balanceTransferIntroAprTermUnit, forKey: "balanceTransferIntroAprTermUnit")
                try container.encodeIfPresent(balanceTransferIntroAprText, forKey: "balanceTransferIntroAprText")
                try container.encodeIfPresent(cardBenefits, forKey: "cardBenefits")
                try container.encodeIfPresent(cardName, forKey: "cardName")
                try container.encodeIfPresent(cardPurposes, forKey: "cardPurposes")
                try container.encodeIfPresent(cardType, forKey: "cardType")
                try container.encodeIfPresent(cashAdvanceAprText, forKey: "cashAdvanceAprText")
                try container.encodeIfPresent(cashAdvanceFee, forKey: "cashAdvanceFee")
                try container.encodeIfPresent(cashAdvanceIntroAprTerm, forKey: "cashAdvanceIntroAprTerm")
                try container.encodeIfPresent(cashAdvanceIntroAprTermUnit, forKey: "cashAdvanceIntroAprTermUnit")
                try container.encodeIfPresent(cashAdvanceIntroAprText, forKey: "cashAdvanceIntroAprText")
                try container.encodeIfPresent(details, forKey: "details")
                try container.encodeIfPresent(earningProgram, forKey: "earningProgram")
                try container.encodeIfPresent(foreignExchangeFee, forKey: "foreignExchangeFee")
                try container.encodeIfPresent(foreignTransactionFee, forKey: "foreignTransactionFee")
                try container.encodeIfPresent(introOfferAmount, forKey: "introOfferAmount")
                try container.encodeIfPresent(introOfferText, forKey: "introOfferText")
                try container.encodeIfPresent(introOfferType, forKey: "introOfferType")
                try container.encodeIfPresent(lateFee, forKey: "lateFee")
                try container.encodeIfPresent(maxAnnualFee, forKey: "maxAnnualFee")
                try container.encodeIfPresent(maxBalanceTransferApr, forKey: "maxBalanceTransferApr")
                try container.encodeIfPresent(maxBalanceTransferIntroApr, forKey: "maxBalanceTransferIntroApr")
                try container.encodeIfPresent(maxCashAdvanceApr, forKey: "maxCashAdvanceApr")
                try container.encodeIfPresent(maxCashAdvanceIntroApr, forKey: "maxCashAdvanceIntroApr")
                try container.encodeIfPresent(maxPurchaseApr, forKey: "maxPurchaseApr")
                try container.encodeIfPresent(maxPurchaseIntroApr, forKey: "maxPurchaseIntroApr")
                try container.encodeIfPresent(maximumPenaltyApr, forKey: "maximumPenaltyApr")
                try container.encodeIfPresent(minAnnualFee, forKey: "minAnnualFee")
                try container.encodeIfPresent(minBalanceTransferApr, forKey: "minBalanceTransferApr")
                try container.encodeIfPresent(minBalanceTransferIntroApr, forKey: "minBalanceTransferIntroApr")
                try container.encodeIfPresent(minCashAdvanceApr, forKey: "minCashAdvanceApr")
                try container.encodeIfPresent(minCashAdvanceIntroApr, forKey: "minCashAdvanceIntroApr")
                try container.encodeIfPresent(minPurchaseApr, forKey: "minPurchaseApr")
                try container.encodeIfPresent(minPurchaseIntroApr, forKey: "minPurchaseIntroApr")
                try container.encodeIfPresent(minimumCreditLine, forKey: "minimumCreditLine")
                try container.encodeIfPresent(minimumPenaltyApr, forKey: "minimumPenaltyApr")
                try container.encodeIfPresent(monthlyServiceFee, forKey: "monthlyServiceFee")
                try container.encodeIfPresent(preSelected, forKey: "preSelected")
                try container.encodeIfPresent(purchaseAprText, forKey: "purchaseAprText")
                try container.encodeIfPresent(purchaseIntroAprTerm, forKey: "purchaseIntroAprTerm")
                try container.encodeIfPresent(purchaseIntroAprTermUnit, forKey: "purchaseIntroAprTermUnit")
                try container.encodeIfPresent(purchaseIntroAprText, forKey: "purchaseIntroAprText")
                try container.encodeIfPresent(ratesUrl, forKey: "ratesUrl")
                try container.encodeIfPresent(recommendedCreditRatings, forKey: "recommendedCreditRatings")
                try container.encodeIfPresent(returnPaymentFee, forKey: "returnPaymentFee")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Details else { return false }
              guard self.cardImageUrl == object.cardImageUrl else { return false }
              guard self.preQualified == object.preQualified else { return false }
              guard self.preApproved == object.preApproved else { return false }
              guard self.accountOpeningFee == object.accountOpeningFee else { return false }
              guard self.additionalDetails == object.additionalDetails else { return false }
              guard self.annualIntroFee == object.annualIntroFee else { return false }
              guard self.annualIntroFeeTerm == object.annualIntroFeeTerm else { return false }
              guard self.balanceTransferAprText == object.balanceTransferAprText else { return false }
              guard self.balanceTransferFee == object.balanceTransferFee else { return false }
              guard self.balanceTransferIntroAprTerm == object.balanceTransferIntroAprTerm else { return false }
              guard self.balanceTransferIntroAprTermUnit == object.balanceTransferIntroAprTermUnit else { return false }
              guard self.balanceTransferIntroAprText == object.balanceTransferIntroAprText else { return false }
              guard self.cardBenefits == object.cardBenefits else { return false }
              guard self.cardName == object.cardName else { return false }
              guard self.cardPurposes == object.cardPurposes else { return false }
              guard self.cardType == object.cardType else { return false }
              guard self.cashAdvanceAprText == object.cashAdvanceAprText else { return false }
              guard self.cashAdvanceFee == object.cashAdvanceFee else { return false }
              guard self.cashAdvanceIntroAprTerm == object.cashAdvanceIntroAprTerm else { return false }
              guard self.cashAdvanceIntroAprTermUnit == object.cashAdvanceIntroAprTermUnit else { return false }
              guard self.cashAdvanceIntroAprText == object.cashAdvanceIntroAprText else { return false }
              guard self.details == object.details else { return false }
              guard self.earningProgram == object.earningProgram else { return false }
              guard self.foreignExchangeFee == object.foreignExchangeFee else { return false }
              guard self.foreignTransactionFee == object.foreignTransactionFee else { return false }
              guard self.introOfferAmount == object.introOfferAmount else { return false }
              guard self.introOfferText == object.introOfferText else { return false }
              guard self.introOfferType == object.introOfferType else { return false }
              guard self.lateFee == object.lateFee else { return false }
              guard self.maxAnnualFee == object.maxAnnualFee else { return false }
              guard self.maxBalanceTransferApr == object.maxBalanceTransferApr else { return false }
              guard self.maxBalanceTransferIntroApr == object.maxBalanceTransferIntroApr else { return false }
              guard self.maxCashAdvanceApr == object.maxCashAdvanceApr else { return false }
              guard self.maxCashAdvanceIntroApr == object.maxCashAdvanceIntroApr else { return false }
              guard self.maxPurchaseApr == object.maxPurchaseApr else { return false }
              guard self.maxPurchaseIntroApr == object.maxPurchaseIntroApr else { return false }
              guard self.maximumPenaltyApr == object.maximumPenaltyApr else { return false }
              guard self.minAnnualFee == object.minAnnualFee else { return false }
              guard self.minBalanceTransferApr == object.minBalanceTransferApr else { return false }
              guard self.minBalanceTransferIntroApr == object.minBalanceTransferIntroApr else { return false }
              guard self.minCashAdvanceApr == object.minCashAdvanceApr else { return false }
              guard self.minCashAdvanceIntroApr == object.minCashAdvanceIntroApr else { return false }
              guard self.minPurchaseApr == object.minPurchaseApr else { return false }
              guard self.minPurchaseIntroApr == object.minPurchaseIntroApr else { return false }
              guard self.minimumCreditLine == object.minimumCreditLine else { return false }
              guard self.minimumPenaltyApr == object.minimumPenaltyApr else { return false }
              guard self.monthlyServiceFee == object.monthlyServiceFee else { return false }
              guard self.preSelected == object.preSelected else { return false }
              guard self.purchaseAprText == object.purchaseAprText else { return false }
              guard self.purchaseIntroAprTerm == object.purchaseIntroAprTerm else { return false }
              guard self.purchaseIntroAprTermUnit == object.purchaseIntroAprTermUnit else { return false }
              guard self.purchaseIntroAprText == object.purchaseIntroAprText else { return false }
              guard self.ratesUrl == object.ratesUrl else { return false }
              guard self.recommendedCreditRatings == object.recommendedCreditRatings else { return false }
              guard self.returnPaymentFee == object.returnPaymentFee else { return false }
              return true
            }

            public static func == (lhs: Details, rhs: Details) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(details: Details) {
            self.details = details
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            details = try container.decode("details")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(details, forKey: "details")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? CreditCardOffers else { return false }
          guard self.details == object.details else { return false }
          return true
        }

        public static func == (lhs: CreditCardOffers, rhs: CreditCardOffers) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** A `RateTable` customized to a `Lead` input */
    public class LoanOffers: BirchModel, Decodable, AutoEquatable {

        /** Unit of measure for offer term lengths, or open for a single term.
         */
        public enum EvenTermUnit: String, Codable, Equatable, CaseIterable {
            case day = "day"
            case month = "month"
            case year = "year"
            case `open` = "open"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenTermUnit(rawValue: rawValue) ?? .undecodable
            }
        }

        /** A `RateTable` customized to a `Lead` input */
        public enum EvenAprType: String, Codable, Equatable, CaseIterable {
            case variable = "variable"
            case regular = "regular"
            case fixed = "fixed"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenAprType(rawValue: rawValue) ?? .undecodable
            }
        }

        /** A type of financial product */
        public enum EvenProductSubType: String, Codable, Equatable, CaseIterable {
            case creditCard = "credit_card"
            case securedCard = "secured_card"
            case personalLoan = "personal_loan"
            case studentLoanRefinance = "student_loan_refinance"
            case coApplicantLoan = "co_applicant_loan"
            case lineOfCredit = "line_of_credit"
            case purchase = "purchase"
            case refinance = "refinance"
            case savingsAccount = "savings_account"
            case moneyMarketAccount = "money_market_account"
            case certificateOfDeposit = "certificate_of_deposit"
            case individualRetirementAccount = "individual_retirement_account"
            case cashManagementAccount = "cash_management_account"
            case highInterestChecking = "high_interest_checking"
            case accidentalDeathBenefits = "accidental_death_benefits"
            case termLife = "term_life"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenProductSubType(rawValue: rawValue) ?? .undecodable
            }
        }

        public var termLength: Int

        /** Unit of measure for offer term lengths, or open for a single term.
     */
        public var termUnit: EvenTermUnit

        public var maxAmount: Int

        public var allowPrepayment: Bool

        public var preQualified: Bool

        public var preApproved: Bool

        public var secured: Bool

        public var sponsored: Bool

        public var aprType: EvenAprType

        public var conversionProbability: Double?

        /** The maximum fee, in dollars, for an offer. `maxFeeFixed` should be used instead */
        public var feeFixed: Double?

        /** The maximum percent of loan amount fee for an offer. `maxFeeRate` should be used instead */
        public var feeRate: Double?

        public var maxApr: Double?

        public var maxFeeFixed: Double?

        public var maxFeeRate: Double?

        public var maxMonthlyPayment: Double?

        public var maxTotalPayment: Double?

        public var meanApr: Double?

        public var meanMonthlyPayment: Double?

        public var meanTotalPayment: Double?

        public var minAmount: Int?

        public var minApr: Double?

        public var minFeeFixed: Double?

        public var minFeeRate: Double?

        public var minMonthlyPayment: Double?

        public var minTotalPayment: Double?

        /** The estimated maximum monthly payment, in dollars, for an offer. `maxMonthlyPayment` should be used instead */
        public var monthlyPayment: Double?

        public var originator: EvenItems?

        public var originatorId: String?

        public var payout: Double?

        public var prepaymentFee: Double?

        /** A type of financial product */
        public var productSubType: EvenProductSubType?

        public var productType: EvenItems?

        public var recommendationScore: Double?

        public var terms: String?

        public var url: String?

        public var uuid: ID?

        public init(termLength: Int, termUnit: EvenTermUnit, maxAmount: Int, allowPrepayment: Bool, preQualified: Bool, preApproved: Bool, secured: Bool, sponsored: Bool, aprType: EvenAprType, conversionProbability: Double? = nil, feeFixed: Double? = nil, feeRate: Double? = nil, maxApr: Double? = nil, maxFeeFixed: Double? = nil, maxFeeRate: Double? = nil, maxMonthlyPayment: Double? = nil, maxTotalPayment: Double? = nil, meanApr: Double? = nil, meanMonthlyPayment: Double? = nil, meanTotalPayment: Double? = nil, minAmount: Int? = nil, minApr: Double? = nil, minFeeFixed: Double? = nil, minFeeRate: Double? = nil, minMonthlyPayment: Double? = nil, minTotalPayment: Double? = nil, monthlyPayment: Double? = nil, originator: EvenItems? = nil, originatorId: String? = nil, payout: Double? = nil, prepaymentFee: Double? = nil, productSubType: EvenProductSubType? = nil, productType: EvenItems? = nil, recommendationScore: Double? = nil, terms: String? = nil, url: String? = nil, uuid: ID? = nil) {
            self.termLength = termLength
            self.termUnit = termUnit
            self.maxAmount = maxAmount
            self.allowPrepayment = allowPrepayment
            self.preQualified = preQualified
            self.preApproved = preApproved
            self.secured = secured
            self.sponsored = sponsored
            self.aprType = aprType
            self.conversionProbability = conversionProbability
            self.feeFixed = feeFixed
            self.feeRate = feeRate
            self.maxApr = maxApr
            self.maxFeeFixed = maxFeeFixed
            self.maxFeeRate = maxFeeRate
            self.maxMonthlyPayment = maxMonthlyPayment
            self.maxTotalPayment = maxTotalPayment
            self.meanApr = meanApr
            self.meanMonthlyPayment = meanMonthlyPayment
            self.meanTotalPayment = meanTotalPayment
            self.minAmount = minAmount
            self.minApr = minApr
            self.minFeeFixed = minFeeFixed
            self.minFeeRate = minFeeRate
            self.minMonthlyPayment = minMonthlyPayment
            self.minTotalPayment = minTotalPayment
            self.monthlyPayment = monthlyPayment
            self.originator = originator
            self.originatorId = originatorId
            self.payout = payout
            self.prepaymentFee = prepaymentFee
            self.productSubType = productSubType
            self.productType = productType
            self.recommendationScore = recommendationScore
            self.terms = terms
            self.url = url
            self.uuid = uuid
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            termLength = try container.decode("termLength")
            termUnit = try container.decode("termUnit")
            maxAmount = try container.decode("maxAmount")
            allowPrepayment = try container.decode("allowPrepayment")
            preQualified = try container.decode("preQualified")
            preApproved = try container.decode("preApproved")
            secured = try container.decode("secured")
            sponsored = try container.decode("sponsored")
            aprType = try container.decode("aprType")
            conversionProbability = try container.decodeIfPresent("conversionProbability")
            feeFixed = try container.decodeIfPresent("feeFixed")
            feeRate = try container.decodeIfPresent("feeRate")
            maxApr = try container.decodeIfPresent("maxApr")
            maxFeeFixed = try container.decodeIfPresent("maxFeeFixed")
            maxFeeRate = try container.decodeIfPresent("maxFeeRate")
            maxMonthlyPayment = try container.decodeIfPresent("maxMonthlyPayment")
            maxTotalPayment = try container.decodeIfPresent("maxTotalPayment")
            meanApr = try container.decodeIfPresent("meanApr")
            meanMonthlyPayment = try container.decodeIfPresent("meanMonthlyPayment")
            meanTotalPayment = try container.decodeIfPresent("meanTotalPayment")
            minAmount = try container.decodeIfPresent("minAmount")
            minApr = try container.decodeIfPresent("minApr")
            minFeeFixed = try container.decodeIfPresent("minFeeFixed")
            minFeeRate = try container.decodeIfPresent("minFeeRate")
            minMonthlyPayment = try container.decodeIfPresent("minMonthlyPayment")
            minTotalPayment = try container.decodeIfPresent("minTotalPayment")
            monthlyPayment = try container.decodeIfPresent("monthlyPayment")
            originator = try container.decodeIfPresent("originator")
            originatorId = try container.decodeIfPresent("originatorId")
            payout = try container.decodeIfPresent("payout")
            prepaymentFee = try container.decodeIfPresent("prepaymentFee")
            productSubType = try container.decodeIfPresent("productSubType")
            productType = try container.decodeIfPresent("productType")
            recommendationScore = try container.decodeIfPresent("recommendationScore")
            terms = try container.decodeIfPresent("terms")
            url = try container.decodeIfPresent("url")
            uuid = try container.decodeIfPresent("uuid")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(termLength, forKey: "termLength")
            try container.encode(termUnit, forKey: "termUnit")
            try container.encode(maxAmount, forKey: "maxAmount")
            try container.encode(allowPrepayment, forKey: "allowPrepayment")
            try container.encode(preQualified, forKey: "preQualified")
            try container.encode(preApproved, forKey: "preApproved")
            try container.encode(secured, forKey: "secured")
            try container.encode(sponsored, forKey: "sponsored")
            try container.encode(aprType, forKey: "aprType")
            try container.encodeIfPresent(conversionProbability, forKey: "conversionProbability")
            try container.encodeIfPresent(feeFixed, forKey: "feeFixed")
            try container.encodeIfPresent(feeRate, forKey: "feeRate")
            try container.encodeIfPresent(maxApr, forKey: "maxApr")
            try container.encodeIfPresent(maxFeeFixed, forKey: "maxFeeFixed")
            try container.encodeIfPresent(maxFeeRate, forKey: "maxFeeRate")
            try container.encodeIfPresent(maxMonthlyPayment, forKey: "maxMonthlyPayment")
            try container.encodeIfPresent(maxTotalPayment, forKey: "maxTotalPayment")
            try container.encodeIfPresent(meanApr, forKey: "meanApr")
            try container.encodeIfPresent(meanMonthlyPayment, forKey: "meanMonthlyPayment")
            try container.encodeIfPresent(meanTotalPayment, forKey: "meanTotalPayment")
            try container.encodeIfPresent(minAmount, forKey: "minAmount")
            try container.encodeIfPresent(minApr, forKey: "minApr")
            try container.encodeIfPresent(minFeeFixed, forKey: "minFeeFixed")
            try container.encodeIfPresent(minFeeRate, forKey: "minFeeRate")
            try container.encodeIfPresent(minMonthlyPayment, forKey: "minMonthlyPayment")
            try container.encodeIfPresent(minTotalPayment, forKey: "minTotalPayment")
            try container.encodeIfPresent(monthlyPayment, forKey: "monthlyPayment")
            try container.encodeIfPresent(originator, forKey: "originator")
            try container.encodeIfPresent(originatorId, forKey: "originatorId")
            try container.encodeIfPresent(payout, forKey: "payout")
            try container.encodeIfPresent(prepaymentFee, forKey: "prepaymentFee")
            try container.encodeIfPresent(productSubType, forKey: "productSubType")
            try container.encodeIfPresent(productType, forKey: "productType")
            try container.encodeIfPresent(recommendationScore, forKey: "recommendationScore")
            try container.encodeIfPresent(terms, forKey: "terms")
            try container.encodeIfPresent(url, forKey: "url")
            try container.encodeIfPresent(uuid, forKey: "uuid")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? LoanOffers else { return false }
          guard self.termLength == object.termLength else { return false }
          guard self.termUnit == object.termUnit else { return false }
          guard self.maxAmount == object.maxAmount else { return false }
          guard self.allowPrepayment == object.allowPrepayment else { return false }
          guard self.preQualified == object.preQualified else { return false }
          guard self.preApproved == object.preApproved else { return false }
          guard self.secured == object.secured else { return false }
          guard self.sponsored == object.sponsored else { return false }
          guard self.aprType == object.aprType else { return false }
          guard self.conversionProbability == object.conversionProbability else { return false }
          guard self.feeFixed == object.feeFixed else { return false }
          guard self.feeRate == object.feeRate else { return false }
          guard self.maxApr == object.maxApr else { return false }
          guard self.maxFeeFixed == object.maxFeeFixed else { return false }
          guard self.maxFeeRate == object.maxFeeRate else { return false }
          guard self.maxMonthlyPayment == object.maxMonthlyPayment else { return false }
          guard self.maxTotalPayment == object.maxTotalPayment else { return false }
          guard self.meanApr == object.meanApr else { return false }
          guard self.meanMonthlyPayment == object.meanMonthlyPayment else { return false }
          guard self.meanTotalPayment == object.meanTotalPayment else { return false }
          guard self.minAmount == object.minAmount else { return false }
          guard self.minApr == object.minApr else { return false }
          guard self.minFeeFixed == object.minFeeFixed else { return false }
          guard self.minFeeRate == object.minFeeRate else { return false }
          guard self.minMonthlyPayment == object.minMonthlyPayment else { return false }
          guard self.minTotalPayment == object.minTotalPayment else { return false }
          guard self.monthlyPayment == object.monthlyPayment else { return false }
          guard self.originator == object.originator else { return false }
          guard self.originatorId == object.originatorId else { return false }
          guard self.payout == object.payout else { return false }
          guard self.prepaymentFee == object.prepaymentFee else { return false }
          guard self.productSubType == object.productSubType else { return false }
          guard self.productType == object.productType else { return false }
          guard self.recommendationScore == object.recommendationScore else { return false }
          guard self.terms == object.terms else { return false }
          guard self.url == object.url else { return false }
          guard self.uuid == object.uuid else { return false }
          return true
        }

        public static func == (lhs: LoanOffers, rhs: LoanOffers) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** An offer for a mortgage */
    public class MortgageOffers: BirchModel, Decodable, AutoEquatable {

        public var details: Details

        /** An offer for a mortgage */
        public class Details: BirchModel, Decodable, AutoEquatable {

            /** An offer for a mortgage */
            public enum EvenLoanType: String, Codable, Equatable, CaseIterable {
                case fifteenYearFixed = "fifteen_year_fixed"
                case thirtyYearFixed = "thirty_year_fixed"
                case fiveOneAdjustable = "five_one_adjustable"
                case sevenOneAdjustable = "seven_one_adjustable"
                case tenOneAdjustable = "ten_one_adjustable"
                case undecodable

                public init(from decoder: Decoder) throws {
                    let container = try decoder.singleValueContainer()
                    let rawValue = try container.decode(String.self)
                    self = EvenLoanType(rawValue: rawValue) ?? .undecodable
                }
            }

            /** An offer for a mortgage */
            public enum EvenAdjustmentType: String, Codable, Equatable, CaseIterable {
                case credits = "credits"
                case par = "par"
                case points = "points"
                case undecodable

                public init(from decoder: Decoder) throws {
                    let container = try decoder.singleValueContainer()
                    let rawValue = try container.decode(String.self)
                    self = EvenAdjustmentType(rawValue: rawValue) ?? .undecodable
                }
            }

            public var interestRate: Double

            public var loanType: EvenLoanType

            public var priceAdjustment: Double

            public var monthlyPayment: Double

            public var netClosingCosts: Double

            public var apr: Double

            public var loanTerm: Int

            public var adjustmentType: EvenAdjustmentType

            public init(interestRate: Double, loanType: EvenLoanType, priceAdjustment: Double, monthlyPayment: Double, netClosingCosts: Double, apr: Double, loanTerm: Int, adjustmentType: EvenAdjustmentType) {
                self.interestRate = interestRate
                self.loanType = loanType
                self.priceAdjustment = priceAdjustment
                self.monthlyPayment = monthlyPayment
                self.netClosingCosts = netClosingCosts
                self.apr = apr
                self.loanTerm = loanTerm
                self.adjustmentType = adjustmentType
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                interestRate = try container.decode("interestRate")
                loanType = try container.decode("loanType")
                priceAdjustment = try container.decode("priceAdjustment")
                monthlyPayment = try container.decode("monthlyPayment")
                netClosingCosts = try container.decode("netClosingCosts")
                apr = try container.decode("apr")
                loanTerm = try container.decode("loanTerm")
                adjustmentType = try container.decode("adjustmentType")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encode(interestRate, forKey: "interestRate")
                try container.encode(loanType, forKey: "loanType")
                try container.encode(priceAdjustment, forKey: "priceAdjustment")
                try container.encode(monthlyPayment, forKey: "monthlyPayment")
                try container.encode(netClosingCosts, forKey: "netClosingCosts")
                try container.encode(apr, forKey: "apr")
                try container.encode(loanTerm, forKey: "loanTerm")
                try container.encode(adjustmentType, forKey: "adjustmentType")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Details else { return false }
              guard self.interestRate == object.interestRate else { return false }
              guard self.loanType == object.loanType else { return false }
              guard self.priceAdjustment == object.priceAdjustment else { return false }
              guard self.monthlyPayment == object.monthlyPayment else { return false }
              guard self.netClosingCosts == object.netClosingCosts else { return false }
              guard self.apr == object.apr else { return false }
              guard self.loanTerm == object.loanTerm else { return false }
              guard self.adjustmentType == object.adjustmentType else { return false }
              return true
            }

            public static func == (lhs: Details, rhs: Details) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(details: Details) {
            self.details = details
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            details = try container.decode("details")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(details, forKey: "details")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? MortgageOffers else { return false }
          guard self.details == object.details else { return false }
          return true
        }

        public static func == (lhs: MortgageOffers, rhs: MortgageOffers) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** An offer for a savings account */
    public class SavingsOffers: BirchModel, Decodable, AutoEquatable {

        public var details: Details

        /** An offer for a savings account */
        public class Details: BirchModel, Decodable, AutoEquatable {

            /** An offer for a savings account */
            public enum EvenCompoundingMethod: String, Codable, Equatable, CaseIterable {
                case annually = "annually"
                case continuous = "continuous"
                case daily = "daily"
                case monthly = "monthly"
                case quarterly = "quarterly"
                case semiAnnually = "semiAnnually"
                case simple = "simple"
                case weekly = "weekly"
                case undecodable

                public init(from decoder: Decoder) throws {
                    let container = try decoder.singleValueContainer()
                    let rawValue = try container.decode(String.self)
                    self = EvenCompoundingMethod(rawValue: rawValue) ?? .undecodable
                }
            }

            public var annualPercentYield: Double

            public var compoundingMethod: EvenCompoundingMethod

            public var minimumDeposit: Double

            public var monthlyFee: Double

            /** Whether the account allows checks */
            public var checkWriting: Bool?

            public var description: String?

            public var details: String?

            /** When the offer was last validated, formatted as yyyy-MM-ddTHH:mm:ss.SSSZZ */
            public var effectiveAsOf: DateTime?

            public var introductoryPeriodMonths: Int?

            public var introductoryRate: Double?

            public var minimumDepositWithFees: Double?

            public var name: String?

            /** Annual interest rate */
            public var rate: Double?

            public init(annualPercentYield: Double, compoundingMethod: EvenCompoundingMethod, minimumDeposit: Double, monthlyFee: Double, checkWriting: Bool? = nil, description: String? = nil, details: String? = nil, effectiveAsOf: DateTime? = nil, introductoryPeriodMonths: Int? = nil, introductoryRate: Double? = nil, minimumDepositWithFees: Double? = nil, name: String? = nil, rate: Double? = nil) {
                self.annualPercentYield = annualPercentYield
                self.compoundingMethod = compoundingMethod
                self.minimumDeposit = minimumDeposit
                self.monthlyFee = monthlyFee
                self.checkWriting = checkWriting
                self.description = description
                self.details = details
                self.effectiveAsOf = effectiveAsOf
                self.introductoryPeriodMonths = introductoryPeriodMonths
                self.introductoryRate = introductoryRate
                self.minimumDepositWithFees = minimumDepositWithFees
                self.name = name
                self.rate = rate
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                annualPercentYield = try container.decode("annualPercentYield")
                compoundingMethod = try container.decode("compoundingMethod")
                minimumDeposit = try container.decode("minimumDeposit")
                monthlyFee = try container.decode("monthlyFee")
                checkWriting = try container.decodeIfPresent("checkWriting")
                description = try container.decodeIfPresent("description")
                details = try container.decodeIfPresent("details")
                effectiveAsOf = try container.decodeIfPresent("effectiveAsOf")
                introductoryPeriodMonths = try container.decodeIfPresent("introductoryPeriodMonths")
                introductoryRate = try container.decodeIfPresent("introductoryRate")
                minimumDepositWithFees = try container.decodeIfPresent("minimumDepositWithFees")
                name = try container.decodeIfPresent("name")
                rate = try container.decodeIfPresent("rate")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encode(annualPercentYield, forKey: "annualPercentYield")
                try container.encode(compoundingMethod, forKey: "compoundingMethod")
                try container.encode(minimumDeposit, forKey: "minimumDeposit")
                try container.encode(monthlyFee, forKey: "monthlyFee")
                try container.encodeIfPresent(checkWriting, forKey: "checkWriting")
                try container.encodeIfPresent(description, forKey: "description")
                try container.encodeIfPresent(details, forKey: "details")
                try container.encodeIfPresent(effectiveAsOf, forKey: "effectiveAsOf")
                try container.encodeIfPresent(introductoryPeriodMonths, forKey: "introductoryPeriodMonths")
                try container.encodeIfPresent(introductoryRate, forKey: "introductoryRate")
                try container.encodeIfPresent(minimumDepositWithFees, forKey: "minimumDepositWithFees")
                try container.encodeIfPresent(name, forKey: "name")
                try container.encodeIfPresent(rate, forKey: "rate")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Details else { return false }
              guard self.annualPercentYield == object.annualPercentYield else { return false }
              guard self.compoundingMethod == object.compoundingMethod else { return false }
              guard self.minimumDeposit == object.minimumDeposit else { return false }
              guard self.monthlyFee == object.monthlyFee else { return false }
              guard self.checkWriting == object.checkWriting else { return false }
              guard self.description == object.description else { return false }
              guard self.details == object.details else { return false }
              guard self.effectiveAsOf == object.effectiveAsOf else { return false }
              guard self.introductoryPeriodMonths == object.introductoryPeriodMonths else { return false }
              guard self.introductoryRate == object.introductoryRate else { return false }
              guard self.minimumDepositWithFees == object.minimumDepositWithFees else { return false }
              guard self.name == object.name else { return false }
              guard self.rate == object.rate else { return false }
              return true
            }

            public static func == (lhs: Details, rhs: Details) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(details: Details) {
            self.details = details
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            details = try container.decode("details")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(details, forKey: "details")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? SavingsOffers else { return false }
          guard self.details == object.details else { return false }
          return true
        }

        public static func == (lhs: SavingsOffers, rhs: SavingsOffers) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** A `RateTable` customized to a `Lead` input */
    public class SpecialOffers: BirchModel, Decodable, AutoEquatable {

        /** Description */
        public var desc: String?

        public var name: String?

        public var partnerImageUrl: String?

        public var partnerName: String?

        public var payout: Double?

        public var recommendationScore: Double?

        public var url: String?

        public var uuid: ID?

        public init(desc: String? = nil, name: String? = nil, partnerImageUrl: String? = nil, partnerName: String? = nil, payout: Double? = nil, recommendationScore: Double? = nil, url: String? = nil, uuid: ID? = nil) {
            self.desc = desc
            self.name = name
            self.partnerImageUrl = partnerImageUrl
            self.partnerName = partnerName
            self.payout = payout
            self.recommendationScore = recommendationScore
            self.url = url
            self.uuid = uuid
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            desc = try container.decodeIfPresent("desc")
            name = try container.decodeIfPresent("name")
            partnerImageUrl = try container.decodeIfPresent("partnerImageUrl")
            partnerName = try container.decodeIfPresent("partnerName")
            payout = try container.decodeIfPresent("payout")
            recommendationScore = try container.decodeIfPresent("recommendationScore")
            url = try container.decodeIfPresent("url")
            uuid = try container.decodeIfPresent("uuid")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(desc, forKey: "desc")
            try container.encodeIfPresent(name, forKey: "name")
            try container.encodeIfPresent(partnerImageUrl, forKey: "partnerImageUrl")
            try container.encodeIfPresent(partnerName, forKey: "partnerName")
            try container.encodeIfPresent(payout, forKey: "payout")
            try container.encodeIfPresent(recommendationScore, forKey: "recommendationScore")
            try container.encodeIfPresent(url, forKey: "url")
            try container.encodeIfPresent(uuid, forKey: "uuid")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? SpecialOffers else { return false }
          guard self.desc == object.desc else { return false }
          guard self.name == object.name else { return false }
          guard self.partnerImageUrl == object.partnerImageUrl else { return false }
          guard self.partnerName == object.partnerName else { return false }
          guard self.payout == object.payout else { return false }
          guard self.recommendationScore == object.recommendationScore else { return false }
          guard self.url == object.url else { return false }
          guard self.uuid == object.uuid else { return false }
          return true
        }

        public static func == (lhs: SpecialOffers, rhs: SpecialOffers) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** A `RateTable` customized to a `Lead` input */
    public class PendingOriginators: BirchModel, Decodable, AutoEquatable {

        public var key: String

        public var name: String

        public var images: [Images]

        public var companyUuid: ID?

        public var description: String?

        public var disclaimer: String?

        /** A `RateTable` customized to a `Lead` input */
        public class Images: BirchModel, Decodable, AutoEquatable {

            public var sizeKey: String?

            public var url: String?

            public init(sizeKey: String? = nil, url: String? = nil) {
                self.sizeKey = sizeKey
                self.url = url
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                sizeKey = try container.decodeIfPresent("sizeKey")
                url = try container.decodeIfPresent("url")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(sizeKey, forKey: "sizeKey")
                try container.encodeIfPresent(url, forKey: "url")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Images else { return false }
              guard self.sizeKey == object.sizeKey else { return false }
              guard self.url == object.url else { return false }
              return true
            }

            public static func == (lhs: Images, rhs: Images) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(key: String, name: String, images: [Images], companyUuid: ID? = nil, description: String? = nil, disclaimer: String? = nil) {
            self.key = key
            self.name = name
            self.images = images
            self.companyUuid = companyUuid
            self.description = description
            self.disclaimer = disclaimer
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            key = try container.decode("key")
            name = try container.decode("name")
            images = try container.decodeArray("images")
            companyUuid = try container.decodeIfPresent("companyUuid")
            description = try container.decodeIfPresent("description")
            disclaimer = try container.decodeIfPresent("disclaimer")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(key, forKey: "key")
            try container.encode(name, forKey: "name")
            try container.encode(images, forKey: "images")
            try container.encodeIfPresent(companyUuid, forKey: "companyUuid")
            try container.encodeIfPresent(description, forKey: "description")
            try container.encodeIfPresent(disclaimer, forKey: "disclaimer")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? PendingOriginators else { return false }
          guard self.key == object.key else { return false }
          guard self.name == object.name else { return false }
          guard self.images == object.images else { return false }
          guard self.companyUuid == object.companyUuid else { return false }
          guard self.description == object.description else { return false }
          guard self.disclaimer == object.disclaimer else { return false }
          return true
        }

        public static func == (lhs: PendingOriginators, rhs: PendingOriginators) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** A `RateTable` customized to a `Lead` input */
    public class PendingResponses: BirchModel, Decodable, AutoEquatable {

        public var partner: Partner

        public var productTypes: [EvenItems]

        /** A `RateTable` customized to a `Lead` input */
        public class Partner: BirchModel, Decodable, AutoEquatable {

            public var uuid: ID

            public var name: String

            public var description: String

            public var disclaimer: String

            /** Whether the partner supports returning pre-qualified or pre-approved offers */
            public var supportsPersonalizedOffers: Bool

            public var imageUrl: String

            public init(uuid: ID, name: String, description: String, disclaimer: String, supportsPersonalizedOffers: Bool, imageUrl: String) {
                self.uuid = uuid
                self.name = name
                self.description = description
                self.disclaimer = disclaimer
                self.supportsPersonalizedOffers = supportsPersonalizedOffers
                self.imageUrl = imageUrl
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                uuid = try container.decode("uuid")
                name = try container.decode("name")
                description = try container.decode("description")
                disclaimer = try container.decode("disclaimer")
                supportsPersonalizedOffers = try container.decode("supportsPersonalizedOffers")
                imageUrl = try container.decode("imageUrl")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encode(uuid, forKey: "uuid")
                try container.encode(name, forKey: "name")
                try container.encode(description, forKey: "description")
                try container.encode(disclaimer, forKey: "disclaimer")
                try container.encode(supportsPersonalizedOffers, forKey: "supportsPersonalizedOffers")
                try container.encode(imageUrl, forKey: "imageUrl")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Partner else { return false }
              guard self.uuid == object.uuid else { return false }
              guard self.name == object.name else { return false }
              guard self.description == object.description else { return false }
              guard self.disclaimer == object.disclaimer else { return false }
              guard self.supportsPersonalizedOffers == object.supportsPersonalizedOffers else { return false }
              guard self.imageUrl == object.imageUrl else { return false }
              return true
            }

            public static func == (lhs: Partner, rhs: Partner) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(partner: Partner, productTypes: [EvenItems]) {
            self.partner = partner
            self.productTypes = productTypes
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            partner = try container.decode("partner")
            productTypes = try container.decodeArray("productTypes")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(partner, forKey: "partner")
            try container.encode(productTypes, forKey: "productTypes")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? PendingResponses else { return false }
          guard self.partner == object.partner else { return false }
          guard self.productTypes == object.productTypes else { return false }
          return true
        }

        public static func == (lhs: PendingResponses, rhs: PendingResponses) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(uuid: ID, leadUuid: ID, loanAmount: Int, creditCardOffers: [CreditCardOffers], loanOffers: [LoanOffers], mortgageOffers: [MortgageOffers], savingsOffers: [SavingsOffers], specialOffers: [SpecialOffers], pendingOriginators: [PendingOriginators], pendingResponses: [PendingResponses]) {
        self.uuid = uuid
        self.leadUuid = leadUuid
        self.loanAmount = loanAmount
        self.creditCardOffers = creditCardOffers
        self.loanOffers = loanOffers
        self.mortgageOffers = mortgageOffers
        self.savingsOffers = savingsOffers
        self.specialOffers = specialOffers
        self.pendingOriginators = pendingOriginators
        self.pendingResponses = pendingResponses
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        uuid = try container.decode("uuid")
        leadUuid = try container.decode("leadUuid")
        loanAmount = try container.decode("loanAmount")
        creditCardOffers = try container.decodeArray("creditCardOffers")
        loanOffers = try container.decodeArray("loanOffers")
        mortgageOffers = try container.decodeArray("mortgageOffers")
        savingsOffers = try container.decodeArray("savingsOffers")
        specialOffers = try container.decodeArray("specialOffers")
        pendingOriginators = try container.decodeArray("pendingOriginators")
        pendingResponses = try container.decodeArray("pendingResponses")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encode(uuid, forKey: "uuid")
        try container.encode(leadUuid, forKey: "leadUuid")
        try container.encode(loanAmount, forKey: "loanAmount")
        try container.encode(creditCardOffers, forKey: "creditCardOffers")
        try container.encode(loanOffers, forKey: "loanOffers")
        try container.encode(mortgageOffers, forKey: "mortgageOffers")
        try container.encode(savingsOffers, forKey: "savingsOffers")
        try container.encode(specialOffers, forKey: "specialOffers")
        try container.encode(pendingOriginators, forKey: "pendingOriginators")
        try container.encode(pendingResponses, forKey: "pendingResponses")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? EvenGetRateTable else { return false }
      guard self.uuid == object.uuid else { return false }
      guard self.leadUuid == object.leadUuid else { return false }
      guard self.loanAmount == object.loanAmount else { return false }
      guard self.creditCardOffers == object.creditCardOffers else { return false }
      guard self.loanOffers == object.loanOffers else { return false }
      guard self.mortgageOffers == object.mortgageOffers else { return false }
      guard self.savingsOffers == object.savingsOffers else { return false }
      guard self.specialOffers == object.specialOffers else { return false }
      guard self.pendingOriginators == object.pendingOriginators else { return false }
      guard self.pendingResponses == object.pendingResponses else { return false }
      return true
    }

    public static func == (lhs: EvenGetRateTable, rhs: EvenGetRateTable) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
