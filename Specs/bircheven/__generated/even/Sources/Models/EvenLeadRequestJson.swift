//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class EvenLeadRequestJson: BirchModel, Decodable, AutoEquatable {

    /** Product types in which the `Lead` is interested */
    public enum EvenProductTypes: String, Codable, Equatable, CaseIterable {
        case creditCard = "credit_card"
        case insurance = "insurance"
        case lifeInsurance = "life_insurance"
        case loan = "loan"
        case mortgage = "mortgage"
        case savings = "savings"
        case other = "other"
        case unknown = "unknown"
        case undecodable

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(String.self)
            self = EvenProductTypes(rawValue: rawValue) ?? .undecodable
        }
    }

    /** Arbitrary key-values mappings to associate with a `Lead`. This field can be use to attach `subid`s to a `Lead` */
    public var clientTags: [String: [String]]?

    /** The personal information of a co-applicant that may be considered in the
underwriting and approval of a loan.
 */
    public var coApplicantInformation: CoApplicantInformation?

    public var creditCardInformation: CreditCardInformation?

    /** Credit history information relating to a `Lead` */
    public var creditInformation: CreditInformation?

    public var educationInformation: EducationInformation?

    public var employmentInformation: EmploymentInformation?

    public var financialInformation: FinancialInformation?

    /** Whether the `Lead` has completed an application form */
    public var formCompleted: Bool?

    public var healthInformation: HealthInformation?

    /** Information regarding a `Lead`'s communication concent */
    public var legalInformation: LegalInformation?

    public var loanInformation: LoanInformation?

    public var mortgageInformation: MortgageInformation?

    public var personalInformation: PersonalInformation?

    /** Product types in which the `Lead` is interested */
    public var productTypes: [EvenProductTypes]?

    /** UUID of company from which the `Lead` was referred */
    public var referralCompanyUuid: ID?

    public var savingsInformation: SavingsInformation?

    /** Browsing session information accociated with a `Lead` */
    public var sessionInformation: SessionInformation?

    /** UUID used to link leads across verticals, unique per user per supply sub-account */
    public var sessionUuid: ID?

    /** UUID for internal Even Financial tracking purposes. This field should never be set by 3rd party API consumers */
    public var trackingUuid: ID?

    /** Primary UUID for a `Lead` */
    public var uuid: ID?

    /** The personal information of a co-applicant that may be considered in the
    underwriting and approval of a loan.
     */
    public class CoApplicantInformation: BirchModel, Decodable, AutoEquatable {

        public var annualIncome: Int?

        public var city: String?

        public var dateOfBirth: DateDay?

        public var firstName: String?

        public var lastName: String?

        public var state: EvenState?

        /** Street address (primary address line) */
        public var streetAddress1: String?

        /** Secondary address line */
        public var streetAddress2: String?

        public var zipCode: String?

        public init(annualIncome: Int? = nil, city: String? = nil, dateOfBirth: DateDay? = nil, firstName: String? = nil, lastName: String? = nil, state: EvenState? = nil, streetAddress1: String? = nil, streetAddress2: String? = nil, zipCode: String? = nil) {
            self.annualIncome = annualIncome
            self.city = city
            self.dateOfBirth = dateOfBirth
            self.firstName = firstName
            self.lastName = lastName
            self.state = state
            self.streetAddress1 = streetAddress1
            self.streetAddress2 = streetAddress2
            self.zipCode = zipCode
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            annualIncome = try container.decodeIfPresent("annualIncome")
            city = try container.decodeIfPresent("city")
            dateOfBirth = try container.decodeIfPresent("dateOfBirth")
            firstName = try container.decodeIfPresent("firstName")
            lastName = try container.decodeIfPresent("lastName")
            state = try container.decodeIfPresent("state")
            streetAddress1 = try container.decodeIfPresent("streetAddress1")
            streetAddress2 = try container.decodeIfPresent("streetAddress2")
            zipCode = try container.decodeIfPresent("zipCode")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(annualIncome, forKey: "annualIncome")
            try container.encodeIfPresent(city, forKey: "city")
            try container.encodeIfPresent(dateOfBirth, forKey: "dateOfBirth")
            try container.encodeIfPresent(firstName, forKey: "firstName")
            try container.encodeIfPresent(lastName, forKey: "lastName")
            try container.encodeIfPresent(state, forKey: "state")
            try container.encodeIfPresent(streetAddress1, forKey: "streetAddress1")
            try container.encodeIfPresent(streetAddress2, forKey: "streetAddress2")
            try container.encodeIfPresent(zipCode, forKey: "zipCode")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? CoApplicantInformation else { return false }
          guard self.annualIncome == object.annualIncome else { return false }
          guard self.city == object.city else { return false }
          guard self.dateOfBirth == object.dateOfBirth else { return false }
          guard self.firstName == object.firstName else { return false }
          guard self.lastName == object.lastName else { return false }
          guard self.state == object.state else { return false }
          guard self.streetAddress1 == object.streetAddress1 else { return false }
          guard self.streetAddress2 == object.streetAddress2 else { return false }
          guard self.zipCode == object.zipCode else { return false }
          return true
        }

        public static func == (lhs: CoApplicantInformation, rhs: CoApplicantInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class CreditCardInformation: BirchModel, Decodable, AutoEquatable {

        /** A list of card purposes in which the lead is interested */
        public enum EvenCardPurposes: String, Codable, Equatable, CaseIterable {
            case balanceTransfer = "balance_transfer"
            case cashBack = "cash_back"
            case earningRewards = "earning_rewards"
            case improveCredit = "improve_credit"
            case lowInterest = "low_interest"
            case newToCredit = "new_to_credit"
            case student = "student"
            case travelIncentives = "travel_incentives"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenCardPurposes(rawValue: rawValue) ?? .undecodable
            }
        }

        public var allowAnnualFee: Bool?

        /** A list of card purposes in which the lead is interested */
        public var cardPurposes: [EvenCardPurposes]?

        public init(allowAnnualFee: Bool? = nil, cardPurposes: [EvenCardPurposes]? = nil) {
            self.allowAnnualFee = allowAnnualFee
            self.cardPurposes = cardPurposes
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            allowAnnualFee = try container.decodeIfPresent("allowAnnualFee")
            cardPurposes = try container.decodeArrayIfPresent("cardPurposes")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(allowAnnualFee, forKey: "allowAnnualFee")
            try container.encodeIfPresent(cardPurposes, forKey: "cardPurposes")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? CreditCardInformation else { return false }
          guard self.allowAnnualFee == object.allowAnnualFee else { return false }
          guard self.cardPurposes == object.cardPurposes else { return false }
          return true
        }

        public static func == (lhs: CreditCardInformation, rhs: CreditCardInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** Credit history information relating to a `Lead` */
    public class CreditInformation: BirchModel, Decodable, AutoEquatable {

        /** Credit history information relating to a `Lead` */
        public enum EvenProvidedCreditRating: String, Codable, Equatable, CaseIterable {
            case excellent = "excellent"
            case good = "good"
            case fair = "fair"
            case poor = "poor"
            case limited = "limited"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenProvidedCreditRating(rawValue: rawValue) ?? .undecodable
            }
        }

        public var providedCreditRating: EvenProvidedCreditRating?

        /** FICO credit score provided by a `Lead` */
        public var providedNumericCreditScore: Int?

        public init(providedCreditRating: EvenProvidedCreditRating? = nil, providedNumericCreditScore: Int? = nil) {
            self.providedCreditRating = providedCreditRating
            self.providedNumericCreditScore = providedNumericCreditScore
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            providedCreditRating = try container.decodeIfPresent("providedCreditRating")
            providedNumericCreditScore = try container.decodeIfPresent("providedNumericCreditScore")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(providedCreditRating, forKey: "providedCreditRating")
            try container.encodeIfPresent(providedNumericCreditScore, forKey: "providedNumericCreditScore")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? CreditInformation else { return false }
          guard self.providedCreditRating == object.providedCreditRating else { return false }
          guard self.providedNumericCreditScore == object.providedNumericCreditScore else { return false }
          return true
        }

        public static func == (lhs: CreditInformation, rhs: CreditInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class EducationInformation: BirchModel, Decodable, AutoEquatable {

        public enum EvenGraduateDegreeType: String, Codable, Equatable, CaseIterable {
            case doctorOfMedicine = "doctor_of_medicine"
            case doctorOfOsteopathicMedicine = "doctor_of_osteopathic_medicine"
            case doctorOfOptometry = "doctor_of_optometry"
            case doctorOfDentalMedicine = "doctor_of_dental_medicine"
            case dentariaeMedicinaeDoctoris = "dentariae_medicinae_doctoris"
            case doctorOfDentalSurgery = "doctor_of_dental_surgery"
            case doctorOfVeterinaryMedicine = "doctor_of_veterinary_medicine"
            case doctorOfPharmacy = "doctor_of_pharmacy"
            case veterinariaeMedicinaeDoctoris = "veterinariae_medicinae_doctoris"
            case masterOfArts = "master_of_arts"
            case masterOfScience = "master_of_science"
            case masterOfResearch = "master_of_research"
            case masterOfResearchProject = "master_of_research_project"
            case masterOfStudies = "master_of_studies"
            case masterOfBusinessAdministration = "master_of_business_administration"
            case masterOfLibraryScience = "master_of_library_science"
            case masterOfPublicAdministration = "master_of_public_administration"
            case masterOfPublicHealth = "master_of_public_health"
            case masterOfLaws = "master_of_laws"
            case masterOfArtsLiberalStudies = "master_of_arts_liberal_studies"
            case masterOfFineArts = "master_of_fine_arts"
            case masterOfMusic = "master_of_music"
            case masterOfEducation = "master_of_education"
            case masterOfEngineering = "master_of_engineering"
            case masterOfArchitecture = "master_of_architecture"
            case jurisDoctor = "juris_doctor"
            case other = "other"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenGraduateDegreeType(rawValue: rawValue) ?? .undecodable
            }
        }

        public var educationLevel: Even0?

        public var graduateDegreeType: EvenGraduateDegreeType?

        public var graduationDate: DateDay?

        /** Name of university where a lead received their highest degree.
    A lookup service for possible universiteis is available from using the /leads/universities endpoint.
    To maximize returned offers, this string must match one of the names returned from the lookup.
     */
        public var universityAttended: String?

        public init(educationLevel: Even0? = nil, graduateDegreeType: EvenGraduateDegreeType? = nil, graduationDate: DateDay? = nil, universityAttended: String? = nil) {
            self.educationLevel = educationLevel
            self.graduateDegreeType = graduateDegreeType
            self.graduationDate = graduationDate
            self.universityAttended = universityAttended
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            educationLevel = try container.decodeIfPresent("educationLevel")
            graduateDegreeType = try container.decodeIfPresent("graduateDegreeType")
            graduationDate = try container.decodeIfPresent("graduationDate")
            universityAttended = try container.decodeIfPresent("universityAttended")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(educationLevel, forKey: "educationLevel")
            try container.encodeIfPresent(graduateDegreeType, forKey: "graduateDegreeType")
            try container.encodeIfPresent(graduationDate, forKey: "graduationDate")
            try container.encodeIfPresent(universityAttended, forKey: "universityAttended")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? EducationInformation else { return false }
          guard self.educationLevel == object.educationLevel else { return false }
          guard self.graduateDegreeType == object.graduateDegreeType else { return false }
          guard self.graduationDate == object.graduationDate else { return false }
          guard self.universityAttended == object.universityAttended else { return false }
          return true
        }

        public static func == (lhs: EducationInformation, rhs: EducationInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class EmploymentInformation: BirchModel, Decodable, AutoEquatable {

        /** Whether a `Lead` uses direct deposit for their salary */
        public var directDeposit: Bool?

        public var employerAddress: String?

        public var employerCity: String?

        public var employerName: String?

        public var employerState: String?

        public var employerZip: String?

        public var jobTitle: String?

        public var monthsEmployed: Int?

        public var payDate1: DateDay?

        public var payDate2: DateDay?

        public init(directDeposit: Bool? = nil, employerAddress: String? = nil, employerCity: String? = nil, employerName: String? = nil, employerState: String? = nil, employerZip: String? = nil, jobTitle: String? = nil, monthsEmployed: Int? = nil, payDate1: DateDay? = nil, payDate2: DateDay? = nil) {
            self.directDeposit = directDeposit
            self.employerAddress = employerAddress
            self.employerCity = employerCity
            self.employerName = employerName
            self.employerState = employerState
            self.employerZip = employerZip
            self.jobTitle = jobTitle
            self.monthsEmployed = monthsEmployed
            self.payDate1 = payDate1
            self.payDate2 = payDate2
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            directDeposit = try container.decodeIfPresent("directDeposit")
            employerAddress = try container.decodeIfPresent("employerAddress")
            employerCity = try container.decodeIfPresent("employerCity")
            employerName = try container.decodeIfPresent("employerName")
            employerState = try container.decodeIfPresent("employerState")
            employerZip = try container.decodeIfPresent("employerZip")
            jobTitle = try container.decodeIfPresent("jobTitle")
            monthsEmployed = try container.decodeIfPresent("monthsEmployed")
            payDate1 = try container.decodeIfPresent("payDate1")
            payDate2 = try container.decodeIfPresent("payDate2")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(directDeposit, forKey: "directDeposit")
            try container.encodeIfPresent(employerAddress, forKey: "employerAddress")
            try container.encodeIfPresent(employerCity, forKey: "employerCity")
            try container.encodeIfPresent(employerName, forKey: "employerName")
            try container.encodeIfPresent(employerState, forKey: "employerState")
            try container.encodeIfPresent(employerZip, forKey: "employerZip")
            try container.encodeIfPresent(jobTitle, forKey: "jobTitle")
            try container.encodeIfPresent(monthsEmployed, forKey: "monthsEmployed")
            try container.encodeIfPresent(payDate1, forKey: "payDate1")
            try container.encodeIfPresent(payDate2, forKey: "payDate2")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? EmploymentInformation else { return false }
          guard self.directDeposit == object.directDeposit else { return false }
          guard self.employerAddress == object.employerAddress else { return false }
          guard self.employerCity == object.employerCity else { return false }
          guard self.employerName == object.employerName else { return false }
          guard self.employerState == object.employerState else { return false }
          guard self.employerZip == object.employerZip else { return false }
          guard self.jobTitle == object.jobTitle else { return false }
          guard self.monthsEmployed == object.monthsEmployed else { return false }
          guard self.payDate1 == object.payDate1 else { return false }
          guard self.payDate2 == object.payDate2 else { return false }
          return true
        }

        public static func == (lhs: EmploymentInformation, rhs: EmploymentInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class FinancialInformation: BirchModel, Decodable, AutoEquatable {

        public enum EvenBankAccountType: String, Codable, Equatable, CaseIterable {
            case checking = "checking"
            case savings = "savings"
            case other = "other"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenBankAccountType(rawValue: rawValue) ?? .undecodable
            }
        }

        public enum EvenEmploymentPayFrequency: String, Codable, Equatable, CaseIterable {
            case weekly = "weekly"
            case biweekly = "biweekly"
            case twiceMonthly = "twice_monthly"
            case monthly = "monthly"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenEmploymentPayFrequency(rawValue: rawValue) ?? .undecodable
            }
        }

        public enum EvenEmploymentStatus: String, Codable, Equatable, CaseIterable {
            case employedFullTime = "employed_full_time"
            case employedPartTime = "employed_part_time"
            case military = "military"
            case notEmployed = "not_employed"
            case selfEmployed = "self_employed"
            case retired = "retired"
            case other = "other"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenEmploymentStatus(rawValue: rawValue) ?? .undecodable
            }
        }

        public var annualIncome: Int?

        public var availableAssets: Int?

        public var bankAccountNumber: String?

        public var bankAccountType: EvenBankAccountType?

        public var bankName: String?

        public var bankRoutingNumber: String?

        public var employmentPayFrequency: EvenEmploymentPayFrequency?

        public var employmentStatus: EvenEmploymentStatus?

        public var monthlyDebt: Int?

        public var monthlyHousingPayment: Int?

        public var monthlyNetIncome: Int?

        public var monthsAtBank: Int?

        public var totalAssets: Int?

        public init(annualIncome: Int? = nil, availableAssets: Int? = nil, bankAccountNumber: String? = nil, bankAccountType: EvenBankAccountType? = nil, bankName: String? = nil, bankRoutingNumber: String? = nil, employmentPayFrequency: EvenEmploymentPayFrequency? = nil, employmentStatus: EvenEmploymentStatus? = nil, monthlyDebt: Int? = nil, monthlyHousingPayment: Int? = nil, monthlyNetIncome: Int? = nil, monthsAtBank: Int? = nil, totalAssets: Int? = nil) {
            self.annualIncome = annualIncome
            self.availableAssets = availableAssets
            self.bankAccountNumber = bankAccountNumber
            self.bankAccountType = bankAccountType
            self.bankName = bankName
            self.bankRoutingNumber = bankRoutingNumber
            self.employmentPayFrequency = employmentPayFrequency
            self.employmentStatus = employmentStatus
            self.monthlyDebt = monthlyDebt
            self.monthlyHousingPayment = monthlyHousingPayment
            self.monthlyNetIncome = monthlyNetIncome
            self.monthsAtBank = monthsAtBank
            self.totalAssets = totalAssets
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            annualIncome = try container.decodeIfPresent("annualIncome")
            availableAssets = try container.decodeIfPresent("availableAssets")
            bankAccountNumber = try container.decodeIfPresent("bankAccountNumber")
            bankAccountType = try container.decodeIfPresent("bankAccountType")
            bankName = try container.decodeIfPresent("bankName")
            bankRoutingNumber = try container.decodeIfPresent("bankRoutingNumber")
            employmentPayFrequency = try container.decodeIfPresent("employmentPayFrequency")
            employmentStatus = try container.decodeIfPresent("employmentStatus")
            monthlyDebt = try container.decodeIfPresent("monthlyDebt")
            monthlyHousingPayment = try container.decodeIfPresent("monthlyHousingPayment")
            monthlyNetIncome = try container.decodeIfPresent("monthlyNetIncome")
            monthsAtBank = try container.decodeIfPresent("monthsAtBank")
            totalAssets = try container.decodeIfPresent("totalAssets")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(annualIncome, forKey: "annualIncome")
            try container.encodeIfPresent(availableAssets, forKey: "availableAssets")
            try container.encodeIfPresent(bankAccountNumber, forKey: "bankAccountNumber")
            try container.encodeIfPresent(bankAccountType, forKey: "bankAccountType")
            try container.encodeIfPresent(bankName, forKey: "bankName")
            try container.encodeIfPresent(bankRoutingNumber, forKey: "bankRoutingNumber")
            try container.encodeIfPresent(employmentPayFrequency, forKey: "employmentPayFrequency")
            try container.encodeIfPresent(employmentStatus, forKey: "employmentStatus")
            try container.encodeIfPresent(monthlyDebt, forKey: "monthlyDebt")
            try container.encodeIfPresent(monthlyHousingPayment, forKey: "monthlyHousingPayment")
            try container.encodeIfPresent(monthlyNetIncome, forKey: "monthlyNetIncome")
            try container.encodeIfPresent(monthsAtBank, forKey: "monthsAtBank")
            try container.encodeIfPresent(totalAssets, forKey: "totalAssets")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? FinancialInformation else { return false }
          guard self.annualIncome == object.annualIncome else { return false }
          guard self.availableAssets == object.availableAssets else { return false }
          guard self.bankAccountNumber == object.bankAccountNumber else { return false }
          guard self.bankAccountType == object.bankAccountType else { return false }
          guard self.bankName == object.bankName else { return false }
          guard self.bankRoutingNumber == object.bankRoutingNumber else { return false }
          guard self.employmentPayFrequency == object.employmentPayFrequency else { return false }
          guard self.employmentStatus == object.employmentStatus else { return false }
          guard self.monthlyDebt == object.monthlyDebt else { return false }
          guard self.monthlyHousingPayment == object.monthlyHousingPayment else { return false }
          guard self.monthlyNetIncome == object.monthlyNetIncome else { return false }
          guard self.monthsAtBank == object.monthsAtBank else { return false }
          guard self.totalAssets == object.totalAssets else { return false }
          return true
        }

        public static func == (lhs: FinancialInformation, rhs: FinancialInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class HealthInformation: BirchModel, Decodable, AutoEquatable {

        public enum EvenGender: String, Codable, Equatable, CaseIterable {
            case male = "male"
            case female = "female"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenGender(rawValue: rawValue) ?? .undecodable
            }
        }

        public var gender: EvenGender?

        public var heightInInches: Int?

        public var tobaccoSmoker: Bool?

        public var weightInPounds: Int?

        public init(gender: EvenGender? = nil, heightInInches: Int? = nil, tobaccoSmoker: Bool? = nil, weightInPounds: Int? = nil) {
            self.gender = gender
            self.heightInInches = heightInInches
            self.tobaccoSmoker = tobaccoSmoker
            self.weightInPounds = weightInPounds
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            gender = try container.decodeIfPresent("gender")
            heightInInches = try container.decodeIfPresent("heightInInches")
            tobaccoSmoker = try container.decodeIfPresent("tobaccoSmoker")
            weightInPounds = try container.decodeIfPresent("weightInPounds")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(gender, forKey: "gender")
            try container.encodeIfPresent(heightInInches, forKey: "heightInInches")
            try container.encodeIfPresent(tobaccoSmoker, forKey: "tobaccoSmoker")
            try container.encodeIfPresent(weightInPounds, forKey: "weightInPounds")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? HealthInformation else { return false }
          guard self.gender == object.gender else { return false }
          guard self.heightInInches == object.heightInInches else { return false }
          guard self.tobaccoSmoker == object.tobaccoSmoker else { return false }
          guard self.weightInPounds == object.weightInPounds else { return false }
          return true
        }

        public static func == (lhs: HealthInformation, rhs: HealthInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** Information regarding a `Lead`'s communication concent */
    public class LegalInformation: BirchModel, Decodable, AutoEquatable {

        /** Whether the lead was shown, and consented to a Fair Credit Reporting Act notice */
        public var consentsToFcra: Bool?

        /** Whether the lead was shown, and consented to a Telephone Consumer Protection Act notice */
        public var consentsToTcpa: Bool?

        /** The exact text to which the lead consented */
        public var tcpaLanguage: String?

        public init(consentsToFcra: Bool? = nil, consentsToTcpa: Bool? = nil, tcpaLanguage: String? = nil) {
            self.consentsToFcra = consentsToFcra
            self.consentsToTcpa = consentsToTcpa
            self.tcpaLanguage = tcpaLanguage
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            consentsToFcra = try container.decodeIfPresent("consentsToFcra")
            consentsToTcpa = try container.decodeIfPresent("consentsToTcpa")
            tcpaLanguage = try container.decodeIfPresent("tcpaLanguage")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(consentsToFcra, forKey: "consentsToFcra")
            try container.encodeIfPresent(consentsToTcpa, forKey: "consentsToTcpa")
            try container.encodeIfPresent(tcpaLanguage, forKey: "tcpaLanguage")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? LegalInformation else { return false }
          guard self.consentsToFcra == object.consentsToFcra else { return false }
          guard self.consentsToTcpa == object.consentsToTcpa else { return false }
          guard self.tcpaLanguage == object.tcpaLanguage else { return false }
          return true
        }

        public static func == (lhs: LegalInformation, rhs: LegalInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class LoanInformation: BirchModel, Decodable, AutoEquatable {

        public enum EvenPurpose: String, Codable, Equatable, CaseIterable {
            case autoPurchase = "auto_purchase"
            case autoRefinance = "auto_refinance"
            case baby = "baby"
            case boat = "boat"
            case business = "business"
            case carRepair = "car_repair"
            case cosmetic = "cosmetic"
            case creditCardRefi = "credit_card_refi"
            case debtConsolidation = "debt_consolidation"
            case emergency = "emergency"
            case engagement = "engagement"
            case green = "green"
            case homeImprovement = "home_improvement"
            case homePurchase = "home_purchase"
            case homeRefi = "home_refi"
            case householdExpenses = "household_expenses"
            case largePurchases = "large_purchases"
            case lifeEvent = "life_event"
            case medicalDental = "medical_dental"
            case motorcycle = "motorcycle"
            case movingRelocation = "moving_relocation"
            case rv = "rv"
            case specialOccasion = "special_occasion"
            case studentLoan = "student_loan"
            case studentLoanRefi = "student_loan_refi"
            case taxes = "taxes"
            case vacation = "vacation"
            case wedding = "wedding"
            case other = "other"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenPurpose(rawValue: rawValue) ?? .undecodable
            }
        }

        public var loanAmount: Int?

        public var purpose: EvenPurpose?

        public init(loanAmount: Int? = nil, purpose: EvenPurpose? = nil) {
            self.loanAmount = loanAmount
            self.purpose = purpose
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            loanAmount = try container.decodeIfPresent("loanAmount")
            purpose = try container.decodeIfPresent("purpose")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(loanAmount, forKey: "loanAmount")
            try container.encodeIfPresent(purpose, forKey: "purpose")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? LoanInformation else { return false }
          guard self.loanAmount == object.loanAmount else { return false }
          guard self.purpose == object.purpose else { return false }
          return true
        }

        public static func == (lhs: LoanInformation, rhs: LoanInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class MortgageInformation: BirchModel, Decodable, AutoEquatable {

        public enum EvenMortgageType: String, Codable, Equatable, CaseIterable {
            case purchase = "purchase"
            case refinance = "refinance"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenMortgageType(rawValue: rawValue) ?? .undecodable
            }
        }

        public enum EvenOccupancyType: String, Codable, Equatable, CaseIterable {
            case primary = "primary"
            case secondary = "secondary"
            case investment = "investment"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenOccupancyType(rawValue: rawValue) ?? .undecodable
            }
        }

        public enum EvenPropertySearchStatus: String, Codable, Equatable, CaseIterable {
            case found = "found"
            case notFound = "not_found"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenPropertySearchStatus(rawValue: rawValue) ?? .undecodable
            }
        }

        public enum EvenPropertyStatus: String, Codable, Equatable, CaseIterable {
            case ownOutright = "own_outright"
            case ownWithMortgage = "own_with_mortgage"
            case rent = "rent"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenPropertyStatus(rawValue: rawValue) ?? .undecodable
            }
        }

        public enum EvenPropertyType: String, Codable, Equatable, CaseIterable {
            case rent = "rent"
            case condo = "condo"
            case multiUnit = "multi_unit"
            case singleFamily = "single_family"
            case townhouse = "townhouse"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenPropertyType(rawValue: rawValue) ?? .undecodable
            }
        }

        public enum EvenPurchaseStatus: String, Codable, Equatable, CaseIterable {
            case noOffer = "no_offer"
            case offerAccepted = "offer_accepted"
            case offerPending = "offer_pending"
            case underContract = "under_contract"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenPurchaseStatus(rawValue: rawValue) ?? .undecodable
            }
        }

        public enum EvenRefinanceType: String, Codable, Equatable, CaseIterable {
            case cashOut = "cash_out"
            case rateTerm = "rate_term"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenRefinanceType(rawValue: rawValue) ?? .undecodable
            }
        }

        /** Additional amount the lead will borrow against existing home equity in the case of refinance */
        public var cashOutAmount: Int?

        public var closingDate: DateDay?

        public var currentWithLoan: Bool?

        public var downPaymentAmount: Int?

        public var hasFHALoan: Bool?

        public var lenderName: String?

        /** The amount of the HOA fee for the lead */
        public var monthlyHoaFee: Float?

        /** Amount the lead will borrow */
        public var mortgageAmount: Int?

        public var mortgageBalance: Int?

        /** The name of the company holding the lead's mortgage */
        public var mortgageCompany: String?

        /** The amount of escrow the lead pays */
        public var mortgageEscrowAmount: Float?

        public var mortgageType: EvenMortgageType?

        /** The number of legal units on the property */
        public var numUnits: Int?

        public var occupancyType: EvenOccupancyType?

        /** Street address (primary address line) */
        public var propertyAddress1: String?

        /** Secondary address line */
        public var propertyAddress2: String?

        public var propertyCity: String?

        public var propertyCounty: String?

        public var propertySearchStatus: EvenPropertySearchStatus?

        public var propertyState: String?

        public var propertyStatus: EvenPropertyStatus?

        public var propertyType: EvenPropertyType?

        public var propertyValue: Int?

        public var propertyZipcode: String?

        public var purchaseDate: DateDay?

        public var purchaseStatus: EvenPurchaseStatus?

        /** Amount the lead will borrow for refinancing an existing mortgage */
        public var refinanceAmount: Int?

        public var refinanceType: EvenRefinanceType?

        public init(cashOutAmount: Int? = nil, closingDate: DateDay? = nil, currentWithLoan: Bool? = nil, downPaymentAmount: Int? = nil, hasFHALoan: Bool? = nil, lenderName: String? = nil, monthlyHoaFee: Float? = nil, mortgageAmount: Int? = nil, mortgageBalance: Int? = nil, mortgageCompany: String? = nil, mortgageEscrowAmount: Float? = nil, mortgageType: EvenMortgageType? = nil, numUnits: Int? = nil, occupancyType: EvenOccupancyType? = nil, propertyAddress1: String? = nil, propertyAddress2: String? = nil, propertyCity: String? = nil, propertyCounty: String? = nil, propertySearchStatus: EvenPropertySearchStatus? = nil, propertyState: String? = nil, propertyStatus: EvenPropertyStatus? = nil, propertyType: EvenPropertyType? = nil, propertyValue: Int? = nil, propertyZipcode: String? = nil, purchaseDate: DateDay? = nil, purchaseStatus: EvenPurchaseStatus? = nil, refinanceAmount: Int? = nil, refinanceType: EvenRefinanceType? = nil) {
            self.cashOutAmount = cashOutAmount
            self.closingDate = closingDate
            self.currentWithLoan = currentWithLoan
            self.downPaymentAmount = downPaymentAmount
            self.hasFHALoan = hasFHALoan
            self.lenderName = lenderName
            self.monthlyHoaFee = monthlyHoaFee
            self.mortgageAmount = mortgageAmount
            self.mortgageBalance = mortgageBalance
            self.mortgageCompany = mortgageCompany
            self.mortgageEscrowAmount = mortgageEscrowAmount
            self.mortgageType = mortgageType
            self.numUnits = numUnits
            self.occupancyType = occupancyType
            self.propertyAddress1 = propertyAddress1
            self.propertyAddress2 = propertyAddress2
            self.propertyCity = propertyCity
            self.propertyCounty = propertyCounty
            self.propertySearchStatus = propertySearchStatus
            self.propertyState = propertyState
            self.propertyStatus = propertyStatus
            self.propertyType = propertyType
            self.propertyValue = propertyValue
            self.propertyZipcode = propertyZipcode
            self.purchaseDate = purchaseDate
            self.purchaseStatus = purchaseStatus
            self.refinanceAmount = refinanceAmount
            self.refinanceType = refinanceType
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            cashOutAmount = try container.decodeIfPresent("cashOutAmount")
            closingDate = try container.decodeIfPresent("closingDate")
            currentWithLoan = try container.decodeIfPresent("currentWithLoan")
            downPaymentAmount = try container.decodeIfPresent("downPaymentAmount")
            hasFHALoan = try container.decodeIfPresent("hasFHALoan")
            lenderName = try container.decodeIfPresent("lenderName")
            monthlyHoaFee = try container.decodeIfPresent("monthlyHoaFee")
            mortgageAmount = try container.decodeIfPresent("mortgageAmount")
            mortgageBalance = try container.decodeIfPresent("mortgageBalance")
            mortgageCompany = try container.decodeIfPresent("mortgageCompany")
            mortgageEscrowAmount = try container.decodeIfPresent("mortgageEscrowAmount")
            mortgageType = try container.decodeIfPresent("mortgageType")
            numUnits = try container.decodeIfPresent("numUnits")
            occupancyType = try container.decodeIfPresent("occupancyType")
            propertyAddress1 = try container.decodeIfPresent("propertyAddress1")
            propertyAddress2 = try container.decodeIfPresent("propertyAddress2")
            propertyCity = try container.decodeIfPresent("propertyCity")
            propertyCounty = try container.decodeIfPresent("propertyCounty")
            propertySearchStatus = try container.decodeIfPresent("propertySearchStatus")
            propertyState = try container.decodeIfPresent("propertyState")
            propertyStatus = try container.decodeIfPresent("propertyStatus")
            propertyType = try container.decodeIfPresent("propertyType")
            propertyValue = try container.decodeIfPresent("propertyValue")
            propertyZipcode = try container.decodeIfPresent("propertyZipcode")
            purchaseDate = try container.decodeIfPresent("purchaseDate")
            purchaseStatus = try container.decodeIfPresent("purchaseStatus")
            refinanceAmount = try container.decodeIfPresent("refinanceAmount")
            refinanceType = try container.decodeIfPresent("refinanceType")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(cashOutAmount, forKey: "cashOutAmount")
            try container.encodeIfPresent(closingDate, forKey: "closingDate")
            try container.encodeIfPresent(currentWithLoan, forKey: "currentWithLoan")
            try container.encodeIfPresent(downPaymentAmount, forKey: "downPaymentAmount")
            try container.encodeIfPresent(hasFHALoan, forKey: "hasFHALoan")
            try container.encodeIfPresent(lenderName, forKey: "lenderName")
            try container.encodeIfPresent(monthlyHoaFee, forKey: "monthlyHoaFee")
            try container.encodeIfPresent(mortgageAmount, forKey: "mortgageAmount")
            try container.encodeIfPresent(mortgageBalance, forKey: "mortgageBalance")
            try container.encodeIfPresent(mortgageCompany, forKey: "mortgageCompany")
            try container.encodeIfPresent(mortgageEscrowAmount, forKey: "mortgageEscrowAmount")
            try container.encodeIfPresent(mortgageType, forKey: "mortgageType")
            try container.encodeIfPresent(numUnits, forKey: "numUnits")
            try container.encodeIfPresent(occupancyType, forKey: "occupancyType")
            try container.encodeIfPresent(propertyAddress1, forKey: "propertyAddress1")
            try container.encodeIfPresent(propertyAddress2, forKey: "propertyAddress2")
            try container.encodeIfPresent(propertyCity, forKey: "propertyCity")
            try container.encodeIfPresent(propertyCounty, forKey: "propertyCounty")
            try container.encodeIfPresent(propertySearchStatus, forKey: "propertySearchStatus")
            try container.encodeIfPresent(propertyState, forKey: "propertyState")
            try container.encodeIfPresent(propertyStatus, forKey: "propertyStatus")
            try container.encodeIfPresent(propertyType, forKey: "propertyType")
            try container.encodeIfPresent(propertyValue, forKey: "propertyValue")
            try container.encodeIfPresent(propertyZipcode, forKey: "propertyZipcode")
            try container.encodeIfPresent(purchaseDate, forKey: "purchaseDate")
            try container.encodeIfPresent(purchaseStatus, forKey: "purchaseStatus")
            try container.encodeIfPresent(refinanceAmount, forKey: "refinanceAmount")
            try container.encodeIfPresent(refinanceType, forKey: "refinanceType")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? MortgageInformation else { return false }
          guard self.cashOutAmount == object.cashOutAmount else { return false }
          guard self.closingDate == object.closingDate else { return false }
          guard self.currentWithLoan == object.currentWithLoan else { return false }
          guard self.downPaymentAmount == object.downPaymentAmount else { return false }
          guard self.hasFHALoan == object.hasFHALoan else { return false }
          guard self.lenderName == object.lenderName else { return false }
          guard self.monthlyHoaFee == object.monthlyHoaFee else { return false }
          guard self.mortgageAmount == object.mortgageAmount else { return false }
          guard self.mortgageBalance == object.mortgageBalance else { return false }
          guard self.mortgageCompany == object.mortgageCompany else { return false }
          guard self.mortgageEscrowAmount == object.mortgageEscrowAmount else { return false }
          guard self.mortgageType == object.mortgageType else { return false }
          guard self.numUnits == object.numUnits else { return false }
          guard self.occupancyType == object.occupancyType else { return false }
          guard self.propertyAddress1 == object.propertyAddress1 else { return false }
          guard self.propertyAddress2 == object.propertyAddress2 else { return false }
          guard self.propertyCity == object.propertyCity else { return false }
          guard self.propertyCounty == object.propertyCounty else { return false }
          guard self.propertySearchStatus == object.propertySearchStatus else { return false }
          guard self.propertyState == object.propertyState else { return false }
          guard self.propertyStatus == object.propertyStatus else { return false }
          guard self.propertyType == object.propertyType else { return false }
          guard self.propertyValue == object.propertyValue else { return false }
          guard self.propertyZipcode == object.propertyZipcode else { return false }
          guard self.purchaseDate == object.purchaseDate else { return false }
          guard self.purchaseStatus == object.purchaseStatus else { return false }
          guard self.refinanceAmount == object.refinanceAmount else { return false }
          guard self.refinanceType == object.refinanceType else { return false }
          return true
        }

        public static func == (lhs: MortgageInformation, rhs: MortgageInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class PersonalInformation: BirchModel, Decodable, AutoEquatable {

        public enum EvenBestTimeToCall: String, Codable, Equatable, CaseIterable {
            case morning = "morning"
            case afternoon = "afternoon"
            case evening = "evening"
            case night = "night"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenBestTimeToCall(rawValue: rawValue) ?? .undecodable
            }
        }

        /** Citizenship status */
        public enum EvenCitizenshipStatus: String, Codable, Equatable, CaseIterable {
            case citizen = "citizen"
            case permanentResident = "permanent_resident"
            case other = "other"
            case unknown = "unknown"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenCitizenshipStatus(rawValue: rawValue) ?? .undecodable
            }
        }

        /** A two character upper case state, Puerto Rico, or District of Columbia code */
        public enum EvenState: String, Codable, Equatable, CaseIterable {
            case ak = "AK"
            case al = "AL"
            case ar = "AR"
            case az = "AZ"
            case ca = "CA"
            case co = "CO"
            case ct = "CT"
            case dc = "DC"
            case de = "DE"
            case fl = "FL"
            case ga = "GA"
            case hi = "HI"
            case ia = "IA"
            case id = "ID"
            case il = "IL"
            case `in` = "IN"
            case ks = "KS"
            case ky = "KY"
            case la = "LA"
            case ma = "MA"
            case md = "MD"
            case me = "ME"
            case mi = "MI"
            case mn = "MN"
            case mo = "MO"
            case ms = "MS"
            case mt = "MT"
            case nc = "NC"
            case nd = "ND"
            case ne = "NE"
            case nh = "NH"
            case nj = "NJ"
            case nm = "NM"
            case nv = "NV"
            case ny = "NY"
            case oh = "OH"
            case ok = "OK"
            case or = "OR"
            case pa = "PA"
            case pr = "PR"
            case ri = "RI"
            case sc = "SC"
            case sd = "SD"
            case tn = "TN"
            case tx = "TX"
            case ut = "UT"
            case va = "VA"
            case vi = "VI"
            case vt = "VT"
            case wa = "WA"
            case wi = "WI"
            case wv = "WV"
            case wy = "WY"
            case undecodable

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                let rawValue = try container.decode(String.self)
                self = EvenState(rawValue: rawValue) ?? .undecodable
            }
        }

        /** Whether the lead is currently in the military (not a veteran) */
        public var activeMilitary: Bool?

        /** Street address (primary address line) */
        public var address1: String?

        /** Secondary address line */
        public var address2: String?

        public var bestTimeToCall: EvenBestTimeToCall?

        /** Citizenship status */
        public var citizenshipStatus: EvenCitizenshipStatus?

        public var city: String?

        public var dateOfBirth: DateDay?

        public var driversLicenseNumber: String?

        /** State in which the driver's license was issued */
        public var driversLicenseState: String?

        public var educationLevel: EvenEducationLevel?

        public var email: String?

        public var firstName: String?

        /** IP address */
        public var ipAddress: String?

        public var lastName: String?

        /** Whether the lead is a veteran (should not be used if the lead is active in the military) */
        public var militaryVeteran: Bool?

        /** Number of months the provided address has been the lead's primary residence */
        public var monthsAtAddress: Int?

        public var primaryPhone: String?

        public var ssn: String?

        /** A two character upper case state, Puerto Rico, or District of Columbia code */
        public var state: EvenState?

        public var workPhone: String?

        public var zipcode: String?

        public init(activeMilitary: Bool? = nil, address1: String? = nil, address2: String? = nil, bestTimeToCall: EvenBestTimeToCall? = nil, citizenshipStatus: EvenCitizenshipStatus? = nil, city: String? = nil, dateOfBirth: DateDay? = nil, driversLicenseNumber: String? = nil, driversLicenseState: String? = nil, educationLevel: EvenEducationLevel? = nil, email: String? = nil, firstName: String? = nil, ipAddress: String? = nil, lastName: String? = nil, militaryVeteran: Bool? = nil, monthsAtAddress: Int? = nil, primaryPhone: String? = nil, ssn: String? = nil, state: EvenState? = nil, workPhone: String? = nil, zipcode: String? = nil) {
            self.activeMilitary = activeMilitary
            self.address1 = address1
            self.address2 = address2
            self.bestTimeToCall = bestTimeToCall
            self.citizenshipStatus = citizenshipStatus
            self.city = city
            self.dateOfBirth = dateOfBirth
            self.driversLicenseNumber = driversLicenseNumber
            self.driversLicenseState = driversLicenseState
            self.educationLevel = educationLevel
            self.email = email
            self.firstName = firstName
            self.ipAddress = ipAddress
            self.lastName = lastName
            self.militaryVeteran = militaryVeteran
            self.monthsAtAddress = monthsAtAddress
            self.primaryPhone = primaryPhone
            self.ssn = ssn
            self.state = state
            self.workPhone = workPhone
            self.zipcode = zipcode
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            activeMilitary = try container.decodeIfPresent("activeMilitary")
            address1 = try container.decodeIfPresent("address1")
            address2 = try container.decodeIfPresent("address2")
            bestTimeToCall = try container.decodeIfPresent("bestTimeToCall")
            citizenshipStatus = try container.decodeIfPresent("citizenshipStatus")
            city = try container.decodeIfPresent("city")
            dateOfBirth = try container.decodeIfPresent("dateOfBirth")
            driversLicenseNumber = try container.decodeIfPresent("driversLicenseNumber")
            driversLicenseState = try container.decodeIfPresent("driversLicenseState")
            educationLevel = try container.decodeIfPresent("educationLevel")
            email = try container.decodeIfPresent("email")
            firstName = try container.decodeIfPresent("firstName")
            ipAddress = try container.decodeIfPresent("ipAddress")
            lastName = try container.decodeIfPresent("lastName")
            militaryVeteran = try container.decodeIfPresent("militaryVeteran")
            monthsAtAddress = try container.decodeIfPresent("monthsAtAddress")
            primaryPhone = try container.decodeIfPresent("primaryPhone")
            ssn = try container.decodeIfPresent("ssn")
            state = try container.decodeIfPresent("state")
            workPhone = try container.decodeIfPresent("workPhone")
            zipcode = try container.decodeIfPresent("zipcode")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(activeMilitary, forKey: "activeMilitary")
            try container.encodeIfPresent(address1, forKey: "address1")
            try container.encodeIfPresent(address2, forKey: "address2")
            try container.encodeIfPresent(bestTimeToCall, forKey: "bestTimeToCall")
            try container.encodeIfPresent(citizenshipStatus, forKey: "citizenshipStatus")
            try container.encodeIfPresent(city, forKey: "city")
            try container.encodeIfPresent(dateOfBirth, forKey: "dateOfBirth")
            try container.encodeIfPresent(driversLicenseNumber, forKey: "driversLicenseNumber")
            try container.encodeIfPresent(driversLicenseState, forKey: "driversLicenseState")
            try container.encodeIfPresent(educationLevel, forKey: "educationLevel")
            try container.encodeIfPresent(email, forKey: "email")
            try container.encodeIfPresent(firstName, forKey: "firstName")
            try container.encodeIfPresent(ipAddress, forKey: "ipAddress")
            try container.encodeIfPresent(lastName, forKey: "lastName")
            try container.encodeIfPresent(militaryVeteran, forKey: "militaryVeteran")
            try container.encodeIfPresent(monthsAtAddress, forKey: "monthsAtAddress")
            try container.encodeIfPresent(primaryPhone, forKey: "primaryPhone")
            try container.encodeIfPresent(ssn, forKey: "ssn")
            try container.encodeIfPresent(state, forKey: "state")
            try container.encodeIfPresent(workPhone, forKey: "workPhone")
            try container.encodeIfPresent(zipcode, forKey: "zipcode")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? PersonalInformation else { return false }
          guard self.activeMilitary == object.activeMilitary else { return false }
          guard self.address1 == object.address1 else { return false }
          guard self.address2 == object.address2 else { return false }
          guard self.bestTimeToCall == object.bestTimeToCall else { return false }
          guard self.citizenshipStatus == object.citizenshipStatus else { return false }
          guard self.city == object.city else { return false }
          guard self.dateOfBirth == object.dateOfBirth else { return false }
          guard self.driversLicenseNumber == object.driversLicenseNumber else { return false }
          guard self.driversLicenseState == object.driversLicenseState else { return false }
          guard self.educationLevel == object.educationLevel else { return false }
          guard self.email == object.email else { return false }
          guard self.firstName == object.firstName else { return false }
          guard self.ipAddress == object.ipAddress else { return false }
          guard self.lastName == object.lastName else { return false }
          guard self.militaryVeteran == object.militaryVeteran else { return false }
          guard self.monthsAtAddress == object.monthsAtAddress else { return false }
          guard self.primaryPhone == object.primaryPhone else { return false }
          guard self.ssn == object.ssn else { return false }
          guard self.state == object.state else { return false }
          guard self.workPhone == object.workPhone else { return false }
          guard self.zipcode == object.zipcode else { return false }
          return true
        }

        public static func == (lhs: PersonalInformation, rhs: PersonalInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class SavingsInformation: BirchModel, Decodable, AutoEquatable {

        /** The minimum amount a `Lead` is interesting in depositing when opening a new savings account */
        public var minDepositAmount: Int?

        public init(minDepositAmount: Int? = nil) {
            self.minDepositAmount = minDepositAmount
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            minDepositAmount = try container.decodeIfPresent("minDepositAmount")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(minDepositAmount, forKey: "minDepositAmount")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? SavingsInformation else { return false }
          guard self.minDepositAmount == object.minDepositAmount else { return false }
          return true
        }

        public static func == (lhs: SavingsInformation, rhs: SavingsInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** Browsing session information accociated with a `Lead` */
    public class SessionInformation: BirchModel, Decodable, AutoEquatable {

        public var ipAddress: String?

        public var userAgent: String?

        public init(ipAddress: String? = nil, userAgent: String? = nil) {
            self.ipAddress = ipAddress
            self.userAgent = userAgent
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            ipAddress = try container.decodeIfPresent("ipAddress")
            userAgent = try container.decodeIfPresent("userAgent")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(ipAddress, forKey: "ipAddress")
            try container.encodeIfPresent(userAgent, forKey: "userAgent")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? SessionInformation else { return false }
          guard self.ipAddress == object.ipAddress else { return false }
          guard self.userAgent == object.userAgent else { return false }
          return true
        }

        public static func == (lhs: SessionInformation, rhs: SessionInformation) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(clientTags: [String: [String]]? = nil, coApplicantInformation: CoApplicantInformation? = nil, creditCardInformation: CreditCardInformation? = nil, creditInformation: CreditInformation? = nil, educationInformation: EducationInformation? = nil, employmentInformation: EmploymentInformation? = nil, financialInformation: FinancialInformation? = nil, formCompleted: Bool? = nil, healthInformation: HealthInformation? = nil, legalInformation: LegalInformation? = nil, loanInformation: LoanInformation? = nil, mortgageInformation: MortgageInformation? = nil, personalInformation: PersonalInformation? = nil, productTypes: [EvenProductTypes]? = nil, referralCompanyUuid: ID? = nil, savingsInformation: SavingsInformation? = nil, sessionInformation: SessionInformation? = nil, sessionUuid: ID? = nil, trackingUuid: ID? = nil, uuid: ID? = nil) {
        self.clientTags = clientTags
        self.coApplicantInformation = coApplicantInformation
        self.creditCardInformation = creditCardInformation
        self.creditInformation = creditInformation
        self.educationInformation = educationInformation
        self.employmentInformation = employmentInformation
        self.financialInformation = financialInformation
        self.formCompleted = formCompleted
        self.healthInformation = healthInformation
        self.legalInformation = legalInformation
        self.loanInformation = loanInformation
        self.mortgageInformation = mortgageInformation
        self.personalInformation = personalInformation
        self.productTypes = productTypes
        self.referralCompanyUuid = referralCompanyUuid
        self.savingsInformation = savingsInformation
        self.sessionInformation = sessionInformation
        self.sessionUuid = sessionUuid
        self.trackingUuid = trackingUuid
        self.uuid = uuid
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        clientTags = try container.decodeIfPresent("clientTags")
        coApplicantInformation = try container.decodeIfPresent("coApplicantInformation")
        creditCardInformation = try container.decodeIfPresent("creditCardInformation")
        creditInformation = try container.decodeIfPresent("creditInformation")
        educationInformation = try container.decodeIfPresent("educationInformation")
        employmentInformation = try container.decodeIfPresent("employmentInformation")
        financialInformation = try container.decodeIfPresent("financialInformation")
        formCompleted = try container.decodeIfPresent("formCompleted")
        healthInformation = try container.decodeIfPresent("healthInformation")
        legalInformation = try container.decodeIfPresent("legalInformation")
        loanInformation = try container.decodeIfPresent("loanInformation")
        mortgageInformation = try container.decodeIfPresent("mortgageInformation")
        personalInformation = try container.decodeIfPresent("personalInformation")
        productTypes = try container.decodeArrayIfPresent("productTypes")
        referralCompanyUuid = try container.decodeIfPresent("referralCompanyUuid")
        savingsInformation = try container.decodeIfPresent("savingsInformation")
        sessionInformation = try container.decodeIfPresent("sessionInformation")
        sessionUuid = try container.decodeIfPresent("sessionUuid")
        trackingUuid = try container.decodeIfPresent("trackingUuid")
        uuid = try container.decodeIfPresent("uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(clientTags, forKey: "clientTags")
        try container.encodeIfPresent(coApplicantInformation, forKey: "coApplicantInformation")
        try container.encodeIfPresent(creditCardInformation, forKey: "creditCardInformation")
        try container.encodeIfPresent(creditInformation, forKey: "creditInformation")
        try container.encodeIfPresent(educationInformation, forKey: "educationInformation")
        try container.encodeIfPresent(employmentInformation, forKey: "employmentInformation")
        try container.encodeIfPresent(financialInformation, forKey: "financialInformation")
        try container.encodeIfPresent(formCompleted, forKey: "formCompleted")
        try container.encodeIfPresent(healthInformation, forKey: "healthInformation")
        try container.encodeIfPresent(legalInformation, forKey: "legalInformation")
        try container.encodeIfPresent(loanInformation, forKey: "loanInformation")
        try container.encodeIfPresent(mortgageInformation, forKey: "mortgageInformation")
        try container.encodeIfPresent(personalInformation, forKey: "personalInformation")
        try container.encodeIfPresent(productTypes, forKey: "productTypes")
        try container.encodeIfPresent(referralCompanyUuid, forKey: "referralCompanyUuid")
        try container.encodeIfPresent(savingsInformation, forKey: "savingsInformation")
        try container.encodeIfPresent(sessionInformation, forKey: "sessionInformation")
        try container.encodeIfPresent(sessionUuid, forKey: "sessionUuid")
        try container.encodeIfPresent(trackingUuid, forKey: "trackingUuid")
        try container.encodeIfPresent(uuid, forKey: "uuid")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? EvenLeadRequestJson else { return false }
      guard self.clientTags == object.clientTags else { return false }
      guard self.coApplicantInformation == object.coApplicantInformation else { return false }
      guard self.creditCardInformation == object.creditCardInformation else { return false }
      guard self.creditInformation == object.creditInformation else { return false }
      guard self.educationInformation == object.educationInformation else { return false }
      guard self.employmentInformation == object.employmentInformation else { return false }
      guard self.financialInformation == object.financialInformation else { return false }
      guard self.formCompleted == object.formCompleted else { return false }
      guard self.healthInformation == object.healthInformation else { return false }
      guard self.legalInformation == object.legalInformation else { return false }
      guard self.loanInformation == object.loanInformation else { return false }
      guard self.mortgageInformation == object.mortgageInformation else { return false }
      guard self.personalInformation == object.personalInformation else { return false }
      guard self.productTypes == object.productTypes else { return false }
      guard self.referralCompanyUuid == object.referralCompanyUuid else { return false }
      guard self.savingsInformation == object.savingsInformation else { return false }
      guard self.sessionInformation == object.sessionInformation else { return false }
      guard self.sessionUuid == object.sessionUuid else { return false }
      guard self.trackingUuid == object.trackingUuid else { return false }
      guard self.uuid == object.uuid else { return false }
      return true
    }

    public static func == (lhs: EvenLeadRequestJson, rhs: EvenLeadRequestJson) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
